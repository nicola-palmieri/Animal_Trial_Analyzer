# ===============================================================
# ðŸ§ª Table Analyzer â€” One-way ANOVA Module (Clean & Minimal)
# ===============================================================

one_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(
          6,
          with_help_tooltip(
            actionButton(ns("run"), "Show results", width = "100%"),
            "Run the ANOVA using the selected response and group variable."
          )
        ),
        column(
          6,
          with_help_tooltip(
            downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
            "Export the ANOVA summaries, post-hoc tests, and diagnostics."
          )
        )
      )
    ),
    results = uiOutput(ns("summary_ui"))
  )
}

one_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    responses <- multi_response_server("response", filtered_data)
    strat_info <- stratification_server("strat", filtered_data)
    
    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, function(x) is.character(x) || is.factor(x))]
      
      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("group"),
            "Categorical predictor",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Choose the grouping variable that defines the comparison categories."
        )
      )
    })
    
    output$level_order <- renderUI({
      req(filtered_data(), input$group)
      levels <- unique(as.character(filtered_data()[[input$group]]))
      with_help_tooltip(
        selectInput(
          ns("order"),
          "Order of levels (first = reference)",
          choices = levels,
          selected = levels,
          multiple = TRUE
        ),
        "Arrange the group levels; the first level is used as the reference in outputs."
      )
    })
    
    models <- eventReactive(input$run, {
      req(filtered_data(), input$group, input$order)
      validate(need(length(responses()) > 0, "Select at least one response variable."))
      prepare_stratified_anova(
        df = filtered_data(),
        responses = responses(),
        model = "oneway_anova",
        factor1_var = input$group,
        factor1_order = input$order,
        stratification = strat_info()
      )
    })
    
    output$download_all <- downloadHandler(
      filename = function() {
        info <- models()
        n_resp <- length(info$responses)
        n_strata <- if (is.null(info$strata)) 0 else length(info$strata$levels)
        label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        paste0("anova_results_", n_resp, "resp_", label, "_", format(Sys.time(), "%Y%m%d-%H%M"), ".docx")
      },
      content = function(file) download_all_anova_results(models(), file)
    )
    
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "One-way ANOVA")
    })
    
    bind_anova_outputs(ns, output, models)
    
    anova_results <- reactive({
      mod <- models()
      req(mod)
      res <- compile_anova_results(mod)
      
      list(
        analysis_type = "ANOVA",
        type = "oneway_anova",
        data_used = mod$data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = list(
          n = nrow(mod$data_used),
          vars = names(mod$data_used)
        ),
        metadata = list(
          responses = mod$responses,
          strata = mod$strata,
          factors = mod$factors,
          orders = mod$orders,
          errors = res$errors
        ),
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })
    
    
    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” One-way ANOVA
# ===============================================================

visualize_oneway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize one-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Lineplots (mean Â± SE)" = "lineplot_mean_se",
            "Barplots (mean Â± SE)"  = "barplot_mean_se"
          ),
          selected = "lineplot_mean_se"
        ),
        "Pick the chart style you prefer for comparing group means and error bars."
      ),
      uiOutput(ns("layout_controls")),
      conditionalPanel(
        condition = sprintf("input['%s'] === 'barplot_mean_se'", ns("plot_type")),
        with_help_tooltip(
          checkboxInput(
            ns("show_bar_labels"),
            "Show value labels on bars",
            value = FALSE
          ),
          "Turn on labels to display the mean value on top of each bar."
        )
      ),
      fluidRow(
        column(6, with_help_tooltip(
          numericInput(ns("plot_width"), "Subplot width (px)", value = 400, min = 200, max = 1200, step = 50),
          "Adjust how wide each subplot should be in pixels."
        )),
        column(6, with_help_tooltip(
          numericInput(ns("plot_height"), "Subplot height (px)", value = 300, min = 200, max = 1200, step = 50),
          "Adjust how tall each subplot should be in pixels."
        ))
      ),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = FALSE)),
        column(6, base_size_ui(
          ns,
          default = 14,
          help_text = "Adjust the base font size used for the ANOVA plots."
        ))
      ),
      br(),
      with_help_tooltip(
        downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
        "Save the current figure as an image file."
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_oneway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    df <- reactive(filtered_data())

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = reactive(NULL),
      multi_group = FALSE
    )

    base_size <- base_size_server(
      input = input,
      default = 14
    )

    cached_results <- reactiveValues(plots = list())

    compute_empty_result <- function(message = NULL) {
      list(
        plot = NULL,
        warning = message,
        layout = NULL,
        defaults = NULL
      )
    }

    empty_plot_results <- function(message) {
      list(
        lineplot_mean_se = compute_empty_result(message),
        barplot_mean_se = compute_empty_result(message)
      )
    }

    compute_all_plots <- function(data, info, layout_inputs, colors, base_size_value) {
      if (is.null(info)) {
        return(list())
      }
      if (!identical(info$type, "oneway_anova")) {
        return(empty_plot_results("No one-way ANOVA results available for plotting."))
      }

      if (is.null(data) || nrow(data) == 0) {
        return(empty_plot_results("No data available for plotting."))
      }

      safe_plot <- function(expr) {
        tryCatch({
          result <- expr
          if (is.null(result)) {
            compute_empty_result("Unable to generate plot.")
          } else {
            result
          }
        }, error = function(e) {
          compute_empty_result(e$message)
        })
      }

      results <- list()

      results$lineplot_mean_se <- safe_plot(
        plot_anova_lineplot_meanse(
          data,
          info,
          layout_inputs,
          line_colors = colors,
          base_size = base_size_value
        )
      )

      posthoc_data <- tryCatch(
        compile_anova_results(info)$posthoc,
        error = function(e) NULL
      )

      results$barplot_mean_se <- safe_plot(
        plot_anova_barplot_meanse(
          data,
          info,
          layout_values = layout_inputs,
          line_colors = colors,
          posthoc_all = posthoc_data,
          show_value_labels = isTRUE(input$show_bar_labels),
          base_size = base_size_value
        )
      )

      results
    }

    observeEvent(
      list(
        model_info(),
        df(),
        input$strata_rows,
        input$strata_cols,
        input$resp_rows,
        input$resp_cols,
        custom_colors(),
        base_size(),
        input$show_bar_labels
      ),
      {
        info <- model_info()
        data <- df()
        layout_inputs <- list(
          strata_rows = input$strata_rows,
          strata_cols = input$strata_cols,
          resp_rows = input$resp_rows,
          resp_cols = input$resp_cols
        )

        cached_results$plots <- compute_all_plots(
          data,
          info,
          layout_inputs,
          custom_colors(),
          base_size()
        )
      },
      ignoreNULL = FALSE
    )

    results <- reactive(cached_results$plots)

    current_result <- reactive({
      res <- results()
      res[[input$plot_type]]
    })

    plot_obj <- reactive({
      result <- current_result()
      if (is.null(result) || !is.null(result$warning)) {
        return(NULL)
      }
      result$plot
    })

    first_non_null <- function(x, default) if (is.null(x)) default else x

    plot_size <- reactive({
      layout <- first_non_null(current_result()$layout, list())
      strata <- first_non_null(layout$strata, list(rows = 1, cols = 1))
      responses <- first_non_null(layout$responses, list(rows = 1, cols = 1))

      list(
        w = input$plot_width * first_non_null(strata$cols, 1) * first_non_null(responses$cols, 1),
        h = input$plot_height * first_non_null(strata$rows, 1) * first_non_null(responses$rows, 1)
      )
    })

    observeEvent(results(), {
      valid <- Filter(function(item) !is.null(item$defaults) && !is.null(item$layout), results())
      if (!length(valid)) {
        return()
      }

      defaults <- valid[[1]]$defaults

      sync_from_defaults <- function(section, rows_id, cols_id) {
        section_defaults <- defaults[[section]]
        if (is.null(section_defaults)) {
          return()
        }
        rows <- section_defaults$rows
        cols <- section_defaults$cols
        if (!is.null(rows)) {
          sync_numeric_input(session, rows_id, input[[rows_id]], rows)
        }
        if (!is.null(cols)) {
          sync_numeric_input(session, cols_id, input[[cols_id]], cols)
        }
      }

      sync_from_defaults("strata", "strata_rows", "strata_cols")
      sync_from_defaults("responses", "resp_rows", "resp_cols")
    }, ignoreNULL = FALSE)

    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })

    output$plot_warning <- renderUI({
      info <- current_result()
      if (is.null(info) || is.null(info$warning)) {
        return(NULL)
      }
      div(class = "alert alert-warning", HTML(info$warning))
    })

    output$plot <- renderPlot(
      {
        plot <- plot_obj()
        if (is.null(plot)) {
          return(NULL)
        }
        plot
      },
      width = function() plot_size()$w,
      height = function() plot_size()$h,
      res = 96
    )

    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_plot_", Sys.Date(), ".png"),
      content = function(file) {
        res <- current_result()
        req(res)
        req(is.null(res$warning))
        plot <- plot_obj()
        req(plot)
        size <- plot_size()
        ggsave(
          filename = file,
          plot = plot,
          device = "png",
          dpi = 300,
          width = size$w / 96,
          height = size$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}

extract_tukey_for_signif <- function(posthoc_entry) {
  if (is.null(posthoc_entry) || !is.data.frame(posthoc_entry)) return(NULL)
  
  df <- posthoc_entry
  
  # split contrast into group1 and group2
  parts <- strsplit(as.character(df$contrast), " - ")
  df$group1 <- vapply(parts, `[`, "", 1)
  df$group2 <- vapply(parts, `[`, "", 2)
  
  # clean p.value column
  df$p.value <- as.character(df$p.value)
  df$p.value <- gsub("\\*", "", df$p.value)          # remove any stars
  df$p.value <- gsub("<0\\.001", "0.0009", df$p.value)  # make "<0.001" numeric
  df$p.value <- suppressWarnings(as.numeric(df$p.value))
  
  df <- df %>%
    dplyr::filter(!is.na(p.value)) %>%
    dplyr::select(group1, group2, p.value)
  
  df
}



# ===============================================================
# ðŸ§  Table Analyzer â€” Shared ANOVA Module Helpers
# ===============================================================

build_anova_layout_controls <- function(ns, input, info) {
  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  n_responses <- if (!is.null(info$responses)) length(info$responses) else 0

  make_grid_input <- function(id, label, help_text) {
    with_help_tooltip(
      numericInput(
        ns(id),
        label,
        value = isolate(if (is.null(input[[id]])) NA else input[[id]]),
        min = 1,
        max = 10,
        step = 1
      ),
      help_text
    )
  }

  build_grid_section <- function(title, row_id, col_id, row_help, col_help) {
    tagList(
      h5(title),
      fluidRow(
        column(width = 6, make_grid_input(row_id, "Grid rows", row_help)),
        column(width = 6, make_grid_input(col_id, "Grid columns", col_help))
      )
    )
  }

  strata_inputs <- if (has_strata) {
    build_grid_section(
      title = "Across strata:",
      row_id = "strata_rows",
      col_id = "strata_cols",
      row_help = "Set how many rows of plots to use when displaying different strata.",
      col_help = "Set how many columns of plots to use when displaying different strata."
    )
  } else {
    NULL
  }

  response_inputs <- if (!is.null(n_responses) && n_responses > 1) {
    build_grid_section(
      title = "Across responses:",
      row_id = "resp_rows",
      col_id = "resp_cols",
      row_help = "Set the number of plot rows when multiple responses are shown together.",
      col_help = "Set the number of plot columns when multiple responses are shown together."
    )
  } else {
    NULL
  }

  tagList(strata_inputs, response_inputs)
}


# ===============================================================
# ðŸ“Š Prepare stratified models for ANOVA (one-way / two-way)
# ===============================================================

prepare_stratified_anova <- function(
    df,
    responses,
    model,
    factor1_var = NULL,
    factor1_order = NULL,
    factor2_var = NULL,
    factor2_order = NULL,
    stratification = NULL,
    stratify_var = NULL,
    strata_order = NULL
) {
  req(df, responses, model)

  if (!is.null(stratification)) {
    if (!is.null(stratification$var)) {
      stratify_var <- stratification$var
    }
    if (!is.null(stratification$levels)) {
      strata_order <- stratification$levels
    }
  }

  set_factor_levels <- function(data, var, levels = NULL, default_factor = FALSE) {
    if (is.null(var) || !var %in% names(data)) return(data)
    if (!is.null(levels)) {
      data[[var]] <- factor(as.character(data[[var]]), levels = levels)
    } else if (default_factor) {
      data[[var]] <- as.factor(as.character(data[[var]]))
    }
    data
  }

  df <- df |>
    set_factor_levels(factor1_var, factor1_order) |>
    set_factor_levels(factor2_var, factor2_order) |>
    set_factor_levels(stratify_var, strata_order, default_factor = TRUE)

  strata <- if (!is.null(stratify_var) && stratify_var %in% names(df)) {
    levels(df[[stratify_var]])
  } else {
    NULL
  }

  rhs <- switch(
    model,
    oneway_anova = factor1_var,
    twoway_anova = if (!is.null(factor1_var) && !is.null(factor2_var)) {
      paste(factor1_var, factor2_var, sep = " *")
    } else {
      factor1_var
    },
    factor1_var
  )
  rhs <- if (is.null(rhs) || rhs == "") "1" else rhs

  build_formula <- function(resp) stats::as.formula(paste(resp, "~", rhs))
  safe_fit <- purrr::safely(function(fml, data) stats::aov(fml, data = data))

  fit_models_for_data <- function(data) {
    lapply(responses, function(resp) {
      fit_result <- safe_fit(build_formula(resp), data)
      list(
        model = fit_result$result,
        error = if (!is.null(fit_result$error)) conditionMessage(fit_result$error) else NULL
      )
    }) |>
      stats::setNames(responses)
  }

  base_info <- list(
    type = model,
    responses = responses,
    factors = list(factor1 = factor1_var, factor2 = factor2_var),
    orders = list(order1 = factor1_order, order2 = factor2_order),
    data_used = df
  )

  if (is.null(strata)) {
    return(c(base_info, list(models = fit_models_for_data(df), strata = NULL)))
  }

  models <- lapply(strata, function(s) {
    subset_rows <- df[[stratify_var]] == s & !is.na(df[[stratify_var]])
    fit_models_for_data(df[subset_rows, , drop = FALSE])
  })
  names(models) <- strata

  c(base_info, list(models = models, strata = list(var = stratify_var, levels = strata)))
}


prepare_anova_outputs <- function(model_obj, factor_names) {
  old_contrasts <- options("contrasts")
  on.exit(options(old_contrasts), add = TRUE)
  options(contrasts = c("contr.sum", "contr.poly"))

  safe_anova <- purrr::safely(function(mod) {
    car::Anova(mod, type = 3)
  })

  anova_result <- safe_anova(model_obj)
  if (!is.null(anova_result$error)) {
    return(list(
      error = conditionMessage(anova_result$error),
      anova_object = NULL,
      anova_table = NULL,
      anova_significant = NULL,
      posthoc_details = list(),
      posthoc_table = NULL,
      posthoc_significant = NULL
    ))
  }

  anova_obj <- anova_result$result
  anova_df <- as.data.frame(anova_obj)
  anova_df$Effect <- rownames(anova_df)
  rownames(anova_df) <- NULL
  anova_df <- anova_df[, c("Effect", setdiff(names(anova_df), "Effect"))]
  
  # --- format p-values and round numeric columns ---
  p_col <- grep("^Pr", names(anova_df), value = TRUE)
  p_col <- if (length(p_col) > 0) p_col[1] else NULL
  raw_p <- if (!is.null(p_col)) anova_df[[p_col]] else rep(NA_real_, nrow(anova_df))
  
  for (col in names(anova_df)) {
    if (is.numeric(anova_df[[col]])) {
      anova_df[[col]] <- round(anova_df[[col]], 2)
    }
  }
  
  anova_significant <- !is.na(raw_p) & raw_p < 0.05
  if (!is.null(p_col)) {
    formatted_p <- format_p_value(raw_p)
    anova_df[[p_col]] <- add_significance_marker(formatted_p, raw_p)
    names(anova_df)[names(anova_df) == p_col] <- "p.value"
  } else {
    anova_df$p.value <- NA_character_
  }
  
  # --- Post-hoc Tukey for each factor ---
  factor_names <- unique(factor_names[!is.na(factor_names) & nzchar(factor_names)])
  posthoc_details <- list()
  posthoc_combined <- NULL
  posthoc_significant <- numeric(0)
  
  for (factor_nm in factor_names) {
    if (!factor_nm %in% names(model_obj$model)) next
    
    res <- tryCatch({
      emm <- emmeans::emmeans(model_obj, specs = factor_nm)
      contrasts <- emmeans::contrast(emm, method = "revpairwise", adjust = "tukey")
      as.data.frame(summary(contrasts))
    }, error = function(e) list(error = e$message))
    
    if (is.data.frame(res)) {
      res$Factor <- factor_nm
      posthoc_details[[factor_nm]] <- list(table = res, error = NULL)
      posthoc_combined <- rbind(posthoc_combined, res)
    } else {
      posthoc_details[[factor_nm]] <- list(table = NULL, error = res$error)
    }
  }
  
  if (!is.null(posthoc_combined)) {
    posthoc_combined <- posthoc_combined[, c("Factor", setdiff(names(posthoc_combined), "Factor"))]
    numeric_cols <- names(posthoc_combined)[sapply(posthoc_combined, is.numeric)]
    if (length(numeric_cols) > 0) {
      for (col in numeric_cols) {
        posthoc_combined[[col]] <- round(posthoc_combined[[col]], 2)
      }
    }
    
    if ("p.value" %in% names(posthoc_combined)) {
      raw_posthoc_p <- posthoc_combined$p.value
      posthoc_significant <- !is.na(raw_posthoc_p) & raw_posthoc_p < 0.05
      formatted_posthoc_p <- format_p_value(raw_posthoc_p)
      posthoc_combined$p.value <- add_significance_marker(formatted_posthoc_p, raw_posthoc_p)
    } else {
      posthoc_significant <- rep(FALSE, nrow(posthoc_combined))
    }
  }

  list(
    error = NULL,
    anova_object = anova_obj,
    anova_table = anova_df,
    anova_significant = anova_significant,
    posthoc_details = posthoc_details,
    posthoc_table = posthoc_combined,
    posthoc_significant = posthoc_significant
  )
}

# ---------------------------------------------------------------
# Collate tidy summaries from ANOVA models
# ---------------------------------------------------------------

compile_anova_results <- function(model_info) {
  if (is.null(model_info) || is.null(model_info$models)) return(NULL)

  factor_names <- unlist(model_info$factors)
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]

  build_effects <- function(outputs) {
    if (is.null(outputs) || is.null(outputs$anova_table)) return(NULL)
    effects <- data.frame(
      Effect = outputs$anova_table$Effect,
      significant = outputs$anova_significant,
      stringsAsFactors = FALSE
    )
    if ("p.value" %in% names(outputs$anova_table)) {
      effects$p.value <- outputs$anova_table$p.value
    }
    effects
  }

  if (is.null(model_info$strata)) {
    summary_list <- list()
    posthoc_list <- list()
    effects_list <- list()
    errors_list <- list()

    for (resp in names(model_info$models)) {
      entry <- model_info$models[[resp]]
      entry_errors <- character(0)
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_errors <- c(entry_errors, outputs$error)
          summary_list[[resp]] <- NULL
          posthoc_list[[resp]] <- NULL
          effects_list[[resp]] <- NULL
        } else {
          summary_list[[resp]] <- outputs$anova_table
          posthoc_list[[resp]] <- outputs$posthoc_table
          effects_list[[resp]] <- build_effects(outputs)
        }
      } else {
        summary_list[[resp]] <- NULL
        posthoc_list[[resp]] <- NULL
        effects_list[[resp]] <- NULL
      }
      if (!is.null(entry$error)) {
        entry_errors <- c(entry_errors, entry$error)
      }
      if (length(entry_errors) > 0) {
        errors_list[[resp]] <- paste(unique(entry_errors), collapse = "\n")
      }
    }

    return(list(
      summary = summary_list,
      posthoc = posthoc_list,
      effects = effects_list,
      errors = errors_list
    ))
  }

  summary_list <- list()
  posthoc_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (stratum_name in names(model_info$models)) {
    stratum_models <- model_info$models[[stratum_name]]
    if (is.null(stratum_models)) next

    for (resp in names(stratum_models)) {
      entry <- stratum_models[[resp]]
      outputs <- NULL
      entry_error <- NULL
      if (!is.null(entry$model)) {
        outputs <- prepare_anova_outputs(entry$model, factor_names)
        if (!is.null(outputs$error)) {
          entry_error <- outputs$error
          outputs <- NULL
        }
      }

      if (is.null(summary_list[[resp]])) summary_list[[resp]] <- list()
      if (is.null(posthoc_list[[resp]])) posthoc_list[[resp]] <- list()
      if (is.null(effects_list[[resp]])) effects_list[[resp]] <- list()
      if (is.null(errors_list[[resp]])) errors_list[[resp]] <- list()

      summary_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$anova_table else NULL
      posthoc_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) outputs$posthoc_table else NULL
      effects_list[[resp]][[stratum_name]] <- if (!is.null(outputs)) build_effects(outputs) else NULL

      if (!is.null(entry$error)) {
        entry_error <- c(entry_error, entry$error)
      }

      if (!is.null(entry_error)) {
        errors_list[[resp]][[stratum_name]] <- paste(unique(entry_error), collapse = "\n")
      }
    }
  }

  list(
    summary = summary_list,
    posthoc = posthoc_list,
    effects = effects_list,
    errors = errors_list
  )
}

# ---------------------------------------------------------------
# Output composition
# ---------------------------------------------------------------
print_anova_summary_and_posthoc <- function(model_entry, factors) {
  if (is.null(model_entry) || (is.list(model_entry) && is.null(model_entry$model))) {
    cat("Model is not available.\n")
    return(invisible(NULL))
  }

  if (!is.null(model_entry$error)) {
    cat(format_safe_error_message("Model fitting failed", model_entry$error), "\n", sep = "")
    return(invisible(NULL))
  }

  model_obj <- model_entry$model
  results <- prepare_anova_outputs(model_obj, factors)
  if (!is.null(results$error)) {
    cat(format_safe_error_message("ANOVA computation failed", results$error), "\n", sep = "")
    return(invisible(NULL))
  }
  if (is.null(results$anova_object)) {
    cat("ANOVA results are unavailable.\n")
    return(invisible(NULL))
  }
  print(results$anova_object)

  if (length(results$posthoc_details) == 0) {
    cat("\nNo post-hoc Tukey comparisons were generated.\n")
  } else {
    for (factor_nm in names(results$posthoc_details)) {
      details <- results$posthoc_details[[factor_nm]]
      if (!is.null(details$error)) {
        cat(
          "\n",
          format_safe_error_message(
            paste("Post-hoc Tukey comparisons for", factor_nm, "failed"),
            details$error
          ),
          "\n",
          sep = ""
        )
      } else if (!is.null(details$table)) {
        cat("\nPost-hoc Tukey comparisons for", factor_nm, ":\n")
        print(details$table)
      }
    }
  }
  invisible(results)
}

bind_single_model_outputs <- function(output, summary_id, download_id,
                                      model_entry, response_name, factors,
                                      stratum_label = NULL) {
  output[[summary_id]] <- renderPrint({
    print_anova_summary_and_posthoc(model_entry, factors)
  })

  output[[download_id]] <- downloadHandler(
    filename = function() {
      base <- paste0("anova_results_", sanitize_name(response_name))
      if (!is.null(stratum_label)) {
        base <- paste0(base, "_stratum_", sanitize_name(stratum_label))
      }
      paste0(base, "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        stop("Model not available for download due to fitting error.")
      }
      results <- prepare_anova_outputs(model_entry$model, factors)
      if (!is.null(results$error)) {
        stop(paste0("ANOVA results unavailable: ", results$error))
      }
      if (is.null(results$anova_table)) {
        stop("ANOVA results are unavailable for export.")
      }
      write_anova_docx(file, results, model_entry$model, response_name, stratum_label)
    }
  )
}

render_anova_results <- function(ns, model_info, module_label = "ANOVA") {
  if (is.null(model_info)) return(NULL)
  
  responses <- model_info$responses
  strata_info <- model_info$strata
  
  # No stratification
  if (is.null(strata_info)) {
    tabs <- lapply(seq_along(responses), function(i) {
      tabPanel(
        title = responses[i],
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i)))
        )
      )
    })
    return(do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs)))
  }
  
  # Stratified
  strata_levels <- strata_info$levels
  tabs <- lapply(seq_along(responses), function(i) {
    response_name <- responses[i]
    stratum_tabs <- lapply(seq_along(strata_levels), function(j) {
      stratum_name <- strata_levels[j]
      tabPanel(
        title = stratum_name,
        tags$div(
          verbatimTextOutput(ns(paste0("summary_", i, "_", j)))
        )
      )
    })
    tabPanel(
      title = response_name,
      do.call(tabsetPanel, c(list(id = ns(paste0("strata_tabs_", i))), stratum_tabs))
    )
  })
  do.call(tabsetPanel, c(list(id = ns("results_tabs")), tabs))
}

bind_anova_outputs <- function(ns, output, models_reactive) {
  observeEvent(models_reactive(), {
    model_info <- models_reactive()
    if (is.null(model_info)) return()
    
    responses <- model_info$responses
    model_list <- model_info$models
    strata_info <- model_info$strata
    factors <- unlist(model_info$factors, use.names = FALSE)
    
    # --- Non-stratified case ---
    if (is.null(strata_info)) {
      for (i in seq_along(responses)) {
        local({
          idx <- i
          response_name <- responses[i]
          model_entry <- model_list[[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx),
            download_id = paste0("download_", idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors
          )
        })
      }
      return()
    }
    
    # --- Stratified case ---
    strata_levels <- strata_info$levels
    for (i in seq_along(responses)) {
      for (j in seq_along(strata_levels)) {
        local({
          idx <- i
          stratum_idx <- j
          response_name <- responses[i]
          stratum_label <- strata_levels[j]
          model_entry <- model_list[[stratum_label]][[response_name]]
          bind_single_model_outputs(
            output,
            summary_id = paste0("summary_", idx, "_", stratum_idx),
            download_id = paste0("download_", idx, "_", stratum_idx),
            model_entry = model_entry,
            response_name = response_name,
            factors = factors,
            stratum_label = stratum_label
          )
        })
      }
    }
  })
}

# ---------------------------------------------------------------
# Results export
# ---------------------------------------------------------------

download_all_anova_results <- function(models_info, file) {
  if (is.null(models_info) || is.null(models_info$models)) {
    stop("No models found to export.")
  }

  combined_results <- list()
  factor_names <- unique(unlist(models_info$factors))
  factor_names <- factor_names[!is.na(factor_names) & nzchar(factor_names)]
  errors <- character(0)

  # --- Case 1: no stratification
  if (is.null(models_info$strata)) {
    for (resp in models_info$responses) {
      model_entry <- models_info$models[[resp]]
      if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
        if (!is.null(model_entry$error)) {
          errors <- c(errors, paste0(resp, ": ", model_entry$error))
        }
        next
      }
      outputs <- prepare_anova_outputs(model_entry$model, factor_names)
      if (!is.null(outputs$error)) {
        errors <- c(errors, paste0(resp, ": ", outputs$error))
        next
      }
      anova_obj <- outputs$anova_object
      if (is.null(anova_obj)) {
        errors <- c(errors, paste0(resp, ": ANOVA results are unavailable."))
        next
      }
      tbl <- as.data.frame(anova_obj)
      tbl$Response <- resp
      tbl$Stratum <- "None"
      tbl$Term <- rownames(tbl)
      rownames(tbl) <- NULL
      names(tbl) <- sub(" ", "", names(tbl))
      tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
      combined_results[[length(combined_results) + 1]] <- tbl
    }
  } else {
    # --- Case 2: stratified
    for (stratum in models_info$strata$levels) {
      for (resp in models_info$responses) {
        model_entry <- models_info$models[[stratum]][[resp]]
        if (is.null(model_entry) || !is.null(model_entry$error) || is.null(model_entry$model)) {
          if (!is.null(model_entry$error)) {
            errors <- c(errors, paste0(resp, " (", stratum, "): ", model_entry$error))
          }
          next
        }
        outputs <- prepare_anova_outputs(model_entry$model, factor_names)
        if (!is.null(outputs$error)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ", outputs$error))
          next
        }
        anova_obj <- outputs$anova_object
        if (is.null(anova_obj)) {
          errors <- c(errors, paste0(resp, " (", stratum, "): ANOVA results are unavailable."))
          next
        }
        tbl <- as.data.frame(anova_obj)
        tbl$Response <- resp
        tbl$Stratum <- stratum
        tbl$Term <- rownames(tbl)
        rownames(tbl) <- NULL
        names(tbl) <- sub(" ", "", names(tbl))
        tbl$PrF <- tbl[, grep("^Pr", names(tbl))[1]]
        combined_results[[length(combined_results) + 1]] <- tbl
      }
    }
  }

  if (length(combined_results) == 0) {
    msg <- "No ANOVA models available to export."
    if (length(errors) > 0) {
      msg <- paste0(
        msg,
        " The following issues were reported:\n",
        paste(sprintf("- %s", unique(errors)), collapse = "\n")
      )
    }
    stop(msg)
  }

  write_anova_docx(combined_results, file)
}

write_anova_docx <- function(results, file) {

  if (is.null(results) || length(results) == 0) stop("No ANOVA results available to export.")
  combined <- bind_rows(results)
  
  required_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF")
  if (!all(required_cols %in% names(combined))) stop("Missing required columns in ANOVA results.")
  
  # Format and sort
  combined <- combined %>%
    mutate(
      SumSq = round(SumSq, 3),
      Fvalue = round(Fvalue, 3),
      PrF_label = ifelse(PrF < 0.001, "<0.001", sprintf("%.3f", PrF)),
      sig = PrF < 0.05
    ) %>%
    arrange(Response, Stratum, Term)
  
  # Hide Stratum column if it's all "None"
  if (length(unique(combined$Stratum)) == 1 && unique(combined$Stratum) == "None") {
    combined$Stratum <- NULL
    visible_cols <- c("Response", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    merge_cols <- c("Response")
  } else {
    visible_cols <- c("Response", "Stratum", "Term", "SumSq", "Df", "Fvalue", "PrF_label")
    merge_cols <- c("Response", "Stratum")
  }
  
  # Build flextable
  ft <- flextable(combined[, visible_cols])
  
  # Clean header names
  ft <- set_header_labels(
    ft,
    Response = "Response",
    Stratum = if ("Stratum" %in% visible_cols) "Stratum" else NULL,
    Term = "Term",
    SumSq = "Sum Sq",
    Df = "Df",
    Fvalue = "F value",
    PrF_label = "Pr(>F)"
  )
  
  # Merge identical group labels
  ft <- merge_v(ft, j = intersect(merge_cols, ft$col_keys))
  
  # Styling
  ft <- fontsize(ft, part = "all", size = 10)
  ft <- bold(ft, part = "header", bold = TRUE)
  ft <- color(ft, part = "header", color = "black")
  ft <- align(ft, align = "center", part = "all")
  
  # Bold significant p-values (< 0.05)
  if ("sig" %in% names(combined)) {
    sig_rows <- which(combined$sig)
    if (length(sig_rows) > 0 && "PrF_label" %in% ft$col_keys) {
      ft <- bold(ft, i = sig_rows, j = "PrF_label", bold = TRUE)
    }
  }
  
  # ===== Journal-style borders =====
  ft <- border_remove(ft)
  black <- fp_border(color = "black", width = 1)
  thin <- fp_border(color = "black", width = 0.5)
  
  # 1) Top line above header
  ft <- border(ft, part = "header", border.top = black)
  # 2) Line below header
  ft <- border(ft, part = "header", border.bottom = black)
  
  # 3) Thin horizontal lines between different responses
  if ("Response" %in% names(combined)) {
    resp_index <- which(diff(as.numeric(factor(combined$Response))) != 0)
    if (length(resp_index) > 0) {
      ft <- border(ft, i = resp_index, part = "body", border.bottom = thin)
    }
  }
  
  # 4) Final bottom border (last line)
  if (nrow(combined) > 0) {
    ft <- border(ft, i = nrow(combined), part = "body", border.bottom = black)
  }
  
  
  # No side or inner borders
  ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
  ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
  
  # Write to DOCX
  doc <- read_docx()
  doc <- body_add_flextable(doc, ft)
  doc <- body_add_par(doc, "")
  doc <- body_add_par(doc, sprintf("Generated by Table Analyzer on %s", Sys.Date()))
  doc <- body_add_par(doc, "Significant p-values (< 0.05) in bold.", style = "Normal")
  print(doc, target = file)
}


# ---------------------------------------------------------------
# Plotting
# ---------------------------------------------------------------

parse_anova_layout_inputs <- function(layout_values) {
  list(
    strata_rows = suppressWarnings(as.numeric(layout_values$strata_rows)),
    strata_cols = suppressWarnings(as.numeric(layout_values$strata_cols)),
    resp_rows   = suppressWarnings(as.numeric(layout_values$resp_rows)),
    resp_cols   = suppressWarnings(as.numeric(layout_values$resp_cols))
  )
}

initialize_anova_plot_context <- function(data, info, layout_values) {
  factor1 <- info$factors$factor1
  factor2 <- info$factors$factor2
  order1 <- info$orders$order1
  order2 <- info$orders$order2

  if (!is.null(factor1) && !is.null(order1) && factor1 %in% names(data)) {
    data[[factor1]] <- factor(data[[factor1]], levels = order1)
  }
  if (!is.null(factor2) && !is.null(order2) && factor2 %in% names(data)) {
    data[[factor2]] <- factor(data[[factor2]], levels = order2)
  }

  has_strata <- !is.null(info$strata) && !is.null(info$strata$var)
  strat_var <- if (has_strata) info$strata$var else NULL
  strata_levels <- if (has_strata) info$strata$levels else character(0)

  if (has_strata && (is.null(strata_levels) || length(strata_levels) == 0) &&
      !is.null(strat_var) && strat_var %in% names(data)) {
    strata_levels <- unique(as.character(stats::na.omit(data[[strat_var]])))
  }

  layout_input <- parse_anova_layout_inputs(layout_values)

  n_expected_strata <- if (has_strata) max(1L, length(strata_levels)) else 1L
  strata_defaults <- if (has_strata) {
    compute_default_grid(n_expected_strata)
  } else {
    list(rows = 1L, cols = 1L)
  }
  strata_layout <- basic_grid_layout(
    rows = layout_input$strata_rows,
    cols = layout_input$strata_cols,
    default_rows = strata_defaults$rows,
    default_cols = strata_defaults$cols
  )

  list(
    data = data,
    responses = info$responses,
    factor1 = factor1,
    factor2 = factor2,
    order1 = order1,
    order2 = order2,
    has_strata = has_strata,
    strat_var = strat_var,
    strata_levels = strata_levels,
    n_expected_strata = n_expected_strata,
    strata_defaults = strata_defaults,
    strata_layout = strata_layout,
    layout_input = layout_input,
    initial_strata_panels = if (has_strata) 0L else 1L
  )
}

anova_summarise_stats <- function(df_subset, resp_name, factor1, factor2) {
  if (is.null(factor1) || !factor1 %in% names(df_subset)) {
    return(tibble::tibble())
  }

  if (is.null(factor2) || !factor2 %in% names(df_subset)) {
    df_subset |>
      dplyr::group_by(.data[[factor1]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  } else {
    df_subset |>
      dplyr::group_by(.data[[factor1]], .data[[factor2]]) |>
      dplyr::summarise(
        mean = mean(.data[[resp_name]], na.rm = TRUE),
        se = sd(.data[[resp_name]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[resp_name]]))),
        .groups = "drop"
      )
  }
}

apply_anova_factor_levels <- function(stats_df, factor1, factor2, order1, order2) {
  if (!is.null(factor1) && factor1 %in% names(stats_df)) {
    if (!is.null(order1)) {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]), levels = order1)
    } else {
      stats_df[[factor1]] <- factor(as.character(stats_df[[factor1]]))
    }
  }

  if (!is.null(factor2) && factor2 %in% names(stats_df)) {
    levels2 <- if (!is.null(order2)) {
      order2
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = levels2)
  }

  stats_df
}

finalize_anova_plot_result <- function(response_plots,
                                       context,
                                       strata_panel_count,
                                       collect_guides = FALSE) {
  if (length(response_plots) == 0) {
    return(NULL)
  }

  has_strata <- context$has_strata
  strata_layout <- context$strata_layout

  if (has_strata && strata_panel_count == 0L) {
    strata_panel_count <- context$n_expected_strata
  }

  if (has_strata) {
    strata_layout <- adjust_grid_layout(max(1L, strata_panel_count), strata_layout)
  }

  response_defaults <- compute_default_grid(length(response_plots))
  response_layout <- basic_grid_layout(
    rows = context$layout_input$resp_rows,
    cols = context$layout_input$resp_cols,
    default_rows = response_defaults$rows,
    default_cols = response_defaults$cols
  )
  response_layout <- adjust_grid_layout(length(response_plots), response_layout)

  strata_validation <- if (has_strata) {
    validate_grid(max(1L, strata_panel_count), strata_layout$nrow, strata_layout$ncol)
  } else {
    list(valid = TRUE, message = NULL)
  }

  response_validation <- validate_grid(
    length(response_plots),
    response_layout$nrow,
    response_layout$ncol
  )

  warnings <- c()
  if (has_strata && !strata_validation$valid && !is.null(strata_validation$message)) {
    warnings <- c(warnings, strata_validation$message)
  }
  if (!response_validation$valid && !is.null(response_validation$message)) {
    warnings <- c(warnings, response_validation$message)
  }
  warning_text <- if (length(warnings) > 0) paste(warnings, collapse = "<br/>") else NULL

  final_plot <- NULL
  if (is.null(warning_text)) {
    if (length(response_plots) == 1) {
      final_plot <- response_plots[[1]]
    } else {
      combined <- patchwork::wrap_plots(
        plotlist = response_plots,
        nrow = response_layout$nrow,
        ncol = response_layout$ncol
      )
      final_plot <- if (collect_guides) {
        combined & patchwork::plot_layout(guides = "collect")
      } else {
        combined
      }
    }
  }

  list(
    plot = final_plot,
    layout = list(
      strata = list(
        rows = if (has_strata) strata_layout$nrow else 1L,
        cols = if (has_strata) strata_layout$ncol else 1L
      ),
      responses = list(
        rows = response_layout$nrow,
        cols = response_layout$ncol
      )
    ),
    warning = warning_text,
    defaults = list(
      strata = context$strata_defaults,
      responses = response_defaults
    )
  )
}

build_line_plot_panel <- function(stats_df,
                                  title_text,
                                  y_limits,
                                  factor1,
                                  factor2,
                                  line_colors,
                                  base_size = 14) {
  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    color_value <- if (!is.null(line_colors) && length(line_colors) > 0) {
      unname(line_colors)[1]
    } else {
      resolve_single_color()
    }
    p <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean)) +
      geom_line(aes(group = 1), color = color_value, linewidth = 1) +
      geom_point(size = 3, color = color_value) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        color = color_value
      ) +
      theme_minimal(base_size = base_size) +
      labs(x = factor1, y = "Mean Â± SE") +
      theme(
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()
      )
  } else {
    group_levels <- if (is.factor(stats_df[[factor2]])) {
      levels(stats_df[[factor2]])
    } else {
      unique(as.character(stats_df[[factor2]]))
    }
    group_levels <- group_levels[!is.na(group_levels)]
    palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
    stats_df[[factor2]] <- factor(as.character(stats_df[[factor2]]), levels = group_levels)
    p <- ggplot(stats_df, aes(
      x = !!sym(factor1),
      y = mean,
      color = !!sym(factor2),
      group = !!sym(factor2)
    )) +
      geom_line(linewidth = 1) +
      geom_point(size = 3) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15
      ) +
      theme_minimal(base_size = base_size) +
      labs(
        x = factor1,
        y = "Mean Â± SE",
        color = factor2
      ) +
      theme(
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()
      ) +
      scale_color_manual(values = palette)
  }

  if (!is.null(y_limits) && all(is.finite(y_limits))) {
    p <- p + scale_y_continuous(limits = y_limits)
  }

  p + ggtitle(title_text) +
    theme(plot.title = element_text(size = 12, face = "bold"))
}

plot_anova_lineplot_meanse <- function(data,
                                       info,
                                       layout_values,
                                       line_colors = NULL,
                                       base_size = 14) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels

  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_stats <- list()
      y_values <- c()

      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) {
          next
        }

        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) {
          next
        }

        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        y_values <- c(y_values, stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
        stratum_stats[[stratum]] <- stats_df
      }

      if (length(stratum_stats) == 0) {
        next
      }

      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }

      strata_panel_count <- max(strata_panel_count, length(stratum_stats))

      strata_plot_list <- lapply(names(stratum_stats), function(stratum_name) {
        build_line_plot_panel(
          stats_df = stratum_stats[[stratum_name]],
          title_text = stratum_name,
          y_limits = y_limits,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_size = base_size
        )
      })

      current_layout <- adjust_grid_layout(length(stratum_stats), context$strata_layout)

      combined <- patchwork::wrap_plots(
        plotlist = strata_plot_list,
        nrow = current_layout$nrow,
        ncol = current_layout$ncol
      )

      title_plot <- ggplot() +
        theme_void() +
        ggtitle(resp) +
        theme(
          plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
          plot.margin = margin(t = 0, r = 0, b = 6, l = 0)
        )

      response_plots[[resp]] <- title_plot / combined + plot_layout(heights = c(0.08, 1))
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) {
        next
      }

      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      y_values <- c(stats_df$mean - stats_df$se, stats_df$mean + stats_df$se)
      y_limits <- range(y_values, na.rm = TRUE)
      if (!all(is.finite(y_limits))) {
        y_limits <- NULL
      }

      response_plots[[resp]] <- build_line_plot_panel(
        stats_df = stats_df,
        title_text = resp,
        y_limits = y_limits,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_size = base_size
      )
    }
  }

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = TRUE
  )
}

build_bar_plot_panel <- function(stats_df,
                                 title_text,
                                 factor1,
                                 factor2,
                                 line_colors,
                                 base_fill,
                                 signif_df = NULL,
                                 show_value_labels = FALSE,
                                 base_size = 14) {
  format_numeric_labels <- scales::label_number(accuracy = 0.01, trim = TRUE)

  if (is.null(factor2) || !factor2 %in% names(stats_df)) {
    plot_obj <- ggplot(stats_df, aes(x = !!sym(factor1), y = mean)) +
      geom_col(fill = base_fill, width = 0.6, alpha = 0.8) +
      geom_errorbar(
        aes(ymin = mean - se, ymax = mean + se),
        width = 0.15,
        color = "gray40",
        linewidth = 0.5
      ) +
      theme_minimal(base_size = base_size) +
      labs(
        x = factor1,
        y = "Mean Â± SE",
        title = title_text
      ) +
      theme(
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
        axis.title.x = element_text(margin = margin(t = 6)),
        axis.title.y = element_text(margin = margin(r = 6)),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(color = "gray90"),
        axis.text.x = element_text(angle = 30, hjust = 1)
      )

    if (isTRUE(show_value_labels)) {
      label_df <- stats_df |>
        dplyr::mutate(
          .se = dplyr::coalesce(se, 0),
          label_text = format_numeric_labels(mean),
          label_y = ifelse(mean >= 0, mean + .se, mean - .se),
          label_vjust = ifelse(mean >= 0, -0.4, 1.2)
        )

      plot_obj <- plot_obj +
        geom_text(
          data = label_df,
          aes(x = !!sym(factor1), y = label_y, label = label_text, vjust = label_vjust),
          color = "gray20",
          size = 3.8,
          fontface = "bold",
          inherit.aes = FALSE
        ) +
        scale_y_continuous(expand = expansion(mult = c(0.05, 0.12)))
    }

    if (!is.null(signif_df) && nrow(signif_df) > 0) {
      signif_df <- signif_df |>
        dplyr::filter(p.value < 0.05)
      if (nrow(signif_df) > 0) {
        max_y <- suppressWarnings(max(stats_df$mean + stats_df$se, na.rm = TRUE))
        if (!is.finite(max_y)) {
          max_y <- 0
        }
        step <- if (isTRUE(all.equal(max_y, 0))) 0.1 else abs(max_y) * 0.08
        start <- max_y + step
        signif_df <- signif_df |>
          dplyr::mutate(
            y_position = seq(
              from = start,
              by = step,
              length.out = dplyr::n()
            ),
            label = dplyr::case_when(
              p.value < 0.001 ~ "***",
              p.value < 0.01 ~ "**",
              p.value < 0.05 ~ "*",
              TRUE ~ sprintf("p=%.3f", p.value)
            ),
            xmin = group1,
            xmax = group2,
            .group_id = seq_len(dplyr::n())
          )

        plot_obj <- plot_obj + ggsignif::geom_signif(
          data = signif_df,
          aes(
            xmin = xmin,
            xmax = xmax,
            annotations = label,
            y_position = y_position,
            group = .group_id
          ),
          manual = TRUE,
          inherit.aes = FALSE,
          tip_length = 0.01,
          textsize = 3.8,
          vjust = 0.5,
          color = "gray30"
        )
      }
    }

    return(plot_obj)
  }

  group_levels <- if (is.factor(stats_df[[factor2]])) {
    levels(stats_df[[factor2]])
  } else {
    unique(as.character(stats_df[[factor2]]))
  }
  group_levels <- group_levels[!is.na(group_levels)]
  palette <- resolve_palette_for_levels(group_levels, custom = line_colors)
  dodge <- position_dodge(width = 0.7)

  plot_obj <- ggplot(stats_df, aes(
    x = !!sym(factor1),
    y = mean,
    fill = !!sym(factor2)
  )) +
    geom_col(position = dodge, width = 0.6, alpha = 0.85) +
    geom_errorbar(
      aes(ymin = mean - se, ymax = mean + se),
      position = dodge,
      width = 0.2,
      color = "gray40",
      linewidth = 0.5
    ) +
    theme_minimal(base_size = base_size) +
    labs(
      x = factor1,
      y = "Mean Â± SE",
      fill = factor2,
      title = title_text
    ) +
    theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      axis.title.x = element_text(margin = margin(t = 6)),
      axis.title.y = element_text(margin = margin(r = 6)),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = "gray90"),
      axis.text.x = element_text(angle = 30, hjust = 1)
    ) +
    scale_fill_manual(values = palette)

  if (isTRUE(show_value_labels)) {
    label_df <- stats_df |>
      dplyr::mutate(
        .se = dplyr::coalesce(se, 0),
        label_text = format_numeric_labels(mean),
        label_y = ifelse(mean >= 0, mean + .se, mean - .se),
        label_vjust = ifelse(mean >= 0, -0.4, 1.2)
      )

    plot_obj <- plot_obj +
      geom_text(
        data = label_df,
        aes(
          x = !!sym(factor1),
          y = label_y,
          label = label_text,
          vjust = label_vjust,
          fill = NULL,
          group = !!sym(factor2)
        ),
        position = dodge,
        color = "gray20",
        size = 3.6,
        fontface = "bold",
        inherit.aes = FALSE
      ) +
      scale_y_continuous(expand = expansion(mult = c(0.05, 0.12)))
  }

  if (!is.null(signif_df) && nrow(signif_df) > 0) {
    signif_df <- signif_df |>
      dplyr::filter(p.value < 0.05)

    if (nrow(signif_df) > 0) {
      if (!factor1 %in% names(signif_df)) {
        signif_df[[factor1]] <- "__overall__"
      }

      lookup <- stats_df |>
        dplyr::mutate(
          .factor1 = as.character(.data[[factor1]]),
          .factor2 = as.character(.data[[factor2]]),
          .x_index = as.numeric(.data[[factor1]]),
          .group_index = as.numeric(.data[[factor2]]),
          .ymax = mean + se
        )

      n_groups <- length(group_levels)
      lookup <- lookup |>
        dplyr::mutate(
          .x_offset = dodge$width * ((.group_index - 0.5) / max(1, n_groups) - 0.5),
          .xpos = .x_index + .x_offset
        )

      signif_split <- split(signif_df, signif_df[[factor1]])
      annotations <- lapply(names(signif_split), function(level_name) {
        subset_df <- signif_split[[level_name]]
        if (nrow(subset_df) == 0) {
          return(NULL)
        }

        level_lookup <- lookup
        if (!identical(level_name, "__overall__") && !is.na(level_name)) {
          level_lookup <- dplyr::filter(level_lookup, .factor1 == level_name)
        }

        if (nrow(level_lookup) == 0) {
          return(NULL)
        }

        base_max <- suppressWarnings(max(level_lookup$.ymax, na.rm = TRUE))
        if (!is.finite(base_max)) {
          base_max <- suppressWarnings(max(lookup$.ymax, na.rm = TRUE))
        }
        if (!is.finite(base_max)) {
          base_max <- 0
        }

        step <- if (isTRUE(all.equal(base_max, 0))) 0.1 else abs(base_max) * 0.08
        start <- base_max + step

        subset_df <- subset_df |>
          dplyr::mutate(
            label = dplyr::case_when(
              p.value < 0.001 ~ "***",
              p.value < 0.01 ~ "**",
              p.value < 0.05 ~ "*",
              TRUE ~ sprintf("p=%.3f", p.value)
            ),
            xmin = vapply(group1, function(g) {
              vals <- level_lookup$.xpos[level_lookup$.factor2 == g]
              if (length(vals) == 0) NA_real_ else vals[1]
            }, numeric(1)),
            xmax = vapply(group2, function(g) {
              vals <- level_lookup$.xpos[level_lookup$.factor2 == g]
              if (length(vals) == 0) NA_real_ else vals[1]
            }, numeric(1)),
            y_position = seq(
              from = start,
              by = step,
              length.out = dplyr::n()
            ),
            .group_id = seq_len(dplyr::n())
          )

        subset_df
      })

      annotations <- annotations[!vapply(annotations, is.null, logical(1))]

      if (length(annotations) > 0) {
        annotations <- dplyr::bind_rows(annotations)
        annotations <- annotations |>
          dplyr::filter(!is.na(xmin), !is.na(xmax))
        if (nrow(annotations) > 0) {
          annotations <- annotations |>
            dplyr::mutate(.group_id = seq_len(dplyr::n()))
        }

        if (nrow(annotations) > 0) {
          plot_obj <- plot_obj + ggsignif::geom_signif(
            data = annotations,
            aes(
              xmin = xmin,
              xmax = xmax,
              annotations = label,
              y_position = y_position,
              group = .group_id
            ),
            manual = TRUE,
            inherit.aes = FALSE,
            tip_length = 0.01,
            textsize = 3.8,
            vjust = 0.5,
            color = "gray30"
          )
        }
      }
    }
  }

  plot_obj
}

prepare_barplot_significance <- function(posthoc_entry, factor1, factor2, stats_df) {
  if (is.null(posthoc_entry)) {
    return(NULL)
  }

  if (is.list(posthoc_entry) && !is.data.frame(posthoc_entry)) {
    if (!is.null(posthoc_entry$table)) {
      return(prepare_barplot_significance(posthoc_entry$table, factor1, factor2, stats_df))
    }

    if (!is.null(factor1) && !is.null(posthoc_entry[[factor1]])) {
      return(prepare_barplot_significance(posthoc_entry[[factor1]], factor1, factor2, stats_df))
    }

    nested <- lapply(posthoc_entry, function(x) {
      prepare_barplot_significance(x, factor1, factor2, stats_df)
    })
    nested <- nested[!vapply(nested, is.null, logical(1))]
    if (length(nested) == 0) {
      return(NULL)
    }

    combined <- dplyr::bind_rows(nested)
    if (nrow(combined) == 0) {
      return(NULL)
    }
    return(combined)
  }

  if (!is.data.frame(posthoc_entry)) {
    return(NULL)
  }

  df <- posthoc_entry
  if ("Factor" %in% names(df) && !is.null(factor2)) {
    df <- df[df$Factor %in% c(
      factor2,
      paste(factor1, factor2, sep = ":"),
      paste(factor2, factor1, sep = ":")
    ), , drop = FALSE]
  }

  if (nrow(df) == 0) {
    return(NULL)
  }

  factor1_levels <- NULL
  if (!is.null(factor1) && factor1 %in% names(stats_df)) {
    factor1_levels <- levels(stats_df[[factor1]])
    if (is.null(factor1_levels)) {
      factor1_levels <- unique(as.character(stats_df[[factor1]]))
    }
  }

  if (!is.null(factor1) && factor1 %in% names(df)) {
    split_df <- split(df, df[[factor1]])
    annotations <- lapply(names(split_df), function(level_name) {
      subset_df <- split_df[[level_name]]
      signif_tbl <- extract_tukey_for_signif(subset_df)
      if (is.null(signif_tbl) || nrow(signif_tbl) == 0) {
        return(NULL)
      }
      signif_tbl[[factor1]] <- level_name
      signif_tbl
    })
    annotations <- annotations[!vapply(annotations, is.null, logical(1))]
    if (length(annotations) == 0) {
      return(NULL)
    }
    combined <- dplyr::bind_rows(annotations)
    if (!is.null(factor1_levels) && factor1 %in% names(combined)) {
      combined[[factor1]] <- factor(combined[[factor1]], levels = factor1_levels)
    }
    return(combined)
  }

  signif_df <- extract_tukey_for_signif(df)
  if (!is.null(signif_df) && nrow(signif_df) > 0 && !is.null(factor1)) {
    signif_df[[factor1]] <- "__overall__"
  }
  signif_df
}

plot_anova_barplot_meanse <- function(data,
                                      info,
                                      layout_values = list(),
                                      line_colors = NULL,
                                      posthoc_all = NULL,
                                      show_value_labels = FALSE,
                                      base_size = 14) {
  context <- initialize_anova_plot_context(data, info, layout_values)
  data <- context$data
  factor1 <- context$factor1
  factor2 <- context$factor2

  if (is.null(factor1) || length(context$responses) == 0) {
    return(NULL)
  }

  base_fill <- if (!is.null(line_colors) && length(line_colors) > 0) {
    unname(line_colors)[1]
  } else {
    "#3E8FC4"
  }

  response_plots <- list()
  strata_panel_count <- context$initial_strata_panels

  for (resp in context$responses) {
    if (context$has_strata && !is.null(context$strat_var) && context$strat_var %in% names(data)) {
      stratum_plots <- list()

      for (stratum in context$strata_levels) {
        subset_rows <- !is.na(data[[context$strat_var]]) & data[[context$strat_var]] == stratum
        subset_data <- data[subset_rows, , drop = FALSE]
        if (nrow(subset_data) == 0) {
          next
        }

        stats_df <- anova_summarise_stats(subset_data, resp, factor1, factor2)
        if (nrow(stats_df) == 0) {
          next
        }

        stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
        posthoc_entry <- NULL
        if (!is.null(posthoc_all) && !is.null(posthoc_all[[resp]])) {
          resp_posthoc <- posthoc_all[[resp]]
          if (is.list(resp_posthoc) && !is.data.frame(resp_posthoc)) {
            posthoc_entry <- resp_posthoc[[stratum]]
          } else {
            posthoc_entry <- resp_posthoc
          }
        }
        signif_df <- prepare_barplot_significance(posthoc_entry, factor1, factor2, stats_df)

        stratum_plots[[stratum]] <- build_bar_plot_panel(
          stats_df = stats_df,
          title_text = stratum,
          factor1 = factor1,
          factor2 = factor2,
          line_colors = line_colors,
          base_fill = base_fill,
          signif_df = signif_df,
          show_value_labels = show_value_labels,
          base_size = base_size
        )
      }

      if (length(stratum_plots) > 0) {
        strata_panel_count <- max(strata_panel_count, length(stratum_plots))
        current_layout <- adjust_grid_layout(length(stratum_plots), context$strata_layout)
        combined <- patchwork::wrap_plots(
          plotlist = stratum_plots,
          nrow = current_layout$nrow,
          ncol = current_layout$ncol
        )

        title_plot <- ggplot() +
          theme_void() +
          ggtitle(resp) +
          theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5))

        response_plots[[resp]] <- title_plot / combined + patchwork::plot_layout(heights = c(0.08, 1))
      }
    } else {
      stats_df <- anova_summarise_stats(data, resp, factor1, factor2)
      if (nrow(stats_df) == 0) {
        next
      }

      stats_df <- apply_anova_factor_levels(stats_df, factor1, factor2, context$order1, context$order2)
      posthoc_entry <- NULL
      if (!is.null(posthoc_all) && !is.null(posthoc_all[[resp]])) {
        posthoc_entry <- posthoc_all[[resp]]
      }
      signif_df <- prepare_barplot_significance(posthoc_entry, factor1, factor2, stats_df)

      response_plots[[resp]] <- build_bar_plot_panel(
        stats_df = stats_df,
        title_text = resp,
        factor1 = factor1,
        factor2 = factor2,
        line_colors = line_colors,
        base_fill = base_fill,
        signif_df = signif_df,
        show_value_labels = show_value_labels,
        base_size = base_size
      )
    }
  }

  finalize_anova_plot_result(
    response_plots = response_plots,
    context = context,
    strata_panel_count = strata_panel_count,
    collect_guides = FALSE
  )
}

# ---------------------------------------------------------------
# Low-level utilities
# ---------------------------------------------------------------
sanitize_name <- function(name) {
  safe <- gsub("[^A-Za-z0-9]+", "_", name)
  safe <- gsub("_+", "_", safe)
  safe <- gsub("^_|_$", "", safe)
  if (!nzchar(safe)) safe <- "unnamed"
  safe
}

format_p_value <- function(p_values) {
  vapply(
    p_values,
    function(p) {
      if (is.na(p)) {
        return(NA_character_)
      }
      if (p < 0.001) {
        "<0.001"
      } else {
        sprintf("%.2f", round(p, 2))
      }
    },
    character(1)
  )
}

add_significance_marker <- function(formatted_p, raw_p) {
  mapply(
    function(fp, rp) {
      if (is.na(rp)) {
        return(fp)
      }
      if (rp < 0.05) {
        paste0(fp, "*")
      } else {
        fp
      }
    },
    formatted_p,
    raw_p,
    USE.NAMES = FALSE
  )
}


# ===============================================================
# ðŸ§ª Table Analyzer â€” Two-way ANOVA Module
# ===============================================================

two_way_anova_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      uiOutput(ns("level_order_1")),
      uiOutput(ns("level_order_2")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the two-way ANOVA with the selected factors and responses."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
          "Save all ANOVA tables, post-hoc results, and diagnostics to disk."
        ))
      )
    ),
    results = tagList(
      uiOutput(ns("summary_ui"))
    )
  )
}

two_way_anova_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    responses <- multi_response_server("response", filtered_data)

    output$inputs <- renderUI({
      req(filtered_data())
      data <- filtered_data()
      cat_cols <- names(data)[sapply(data, function(x) is.character(x) || is.factor(x))]

      tagList(
        multi_response_ui(ns("response")),
        with_help_tooltip(
          selectInput(
            ns("factor1"),
            "Categorical predictor 1 (x-axis)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 0) cat_cols[1] else NULL
          ),
          "Select the factor for the x-axis groups in the interaction plot."
        ),
        with_help_tooltip(
          selectInput(
            ns("factor2"),
            "Categorical predictor 2 (lines)",
            choices = cat_cols,
            selected = if (length(cat_cols) > 1) cat_cols[2] else NULL
          ),
          "Select the factor for the lines in the interaction plot."
        )
      )
    })
    
    strat_info <- stratification_server("strat", filtered_data)
    
    # -----------------------------------------------------------
    # Level order selections
    # -----------------------------------------------------------
    output$level_order_1 <- renderUI({
      req(filtered_data(), input$factor1)
      levels1 <- unique(as.character(filtered_data()[[input$factor1]]))
      with_help_tooltip(
        selectInput(
          ns("order1"),
          paste("Order of levels (first = reference)", input$factor1, "(x-axis)"),
          choices = levels1,
          selected = levels1,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the x-axis; the first level is the reference.", input$factor1)
      )
    })
    
    output$level_order_2 <- renderUI({
      req(filtered_data(), input$factor2)
      levels2 <- unique(as.character(filtered_data()[[input$factor2]]))
      with_help_tooltip(
        selectInput(
          ns("order2"),
          paste("Order of levels (first = reference)", input$factor2, "(lines)"),
          choices = levels2,
          selected = levels2,
          multiple = TRUE
        ),
        sprintf("Arrange the levels of %s for the line colours; the first level is the reference.", input$factor2)
      )
    })
    
    # -----------------------------------------------------------
    # Model fitting (via shared helper)
    # -----------------------------------------------------------
    models <- eventReactive(input$run, {
      req(filtered_data(), input$factor1, input$order1, input$factor2, input$order2)
      resp_vals <- responses()
      validate(
        need(length(resp_vals) > 0, "Please select at least one response variable."),
        need(all(input$order1 %in% unique(filtered_data()[[input$factor1]])), "Invalid level order for first factor."),
        need(all(input$order2 %in% unique(filtered_data()[[input$factor2]])), "Invalid level order for second factor.")
      )
      prepare_stratified_anova(
        df = filtered_data(),
        responses = resp_vals,
        model = "twoway_anova",
        factor1_var = input$factor1,
        factor1_order = input$order1,
        factor2_var = input$factor2,
        factor2_order = input$order2,
        stratification = strat_info()
      )
    })

    # -----------------------------------------------------------
    # Download all results as one combined DOCX
    # -----------------------------------------------------------
    output$download_all <- downloadHandler(
      filename = function() {
        model_info <- models()
        req(model_info)
        
        n_resp <- length(model_info$responses)
        n_strata <- if (is.null(model_info$strata)) 0 else length(model_info$strata$levels)
        strata_label <- ifelse(n_strata == 0, "nostratum", paste0(n_strata, "strata"))
        timestamp <- format(Sys.time(), "%Y%m%d-%H%M")
        sprintf("anova_results_%sresp_%s_%s.docx", n_resp, strata_label, timestamp)
      },
      content = function(file) {
        model_info <- models()
        req(model_info)
        download_all_anova_results(model_info, file)
      }
    )
    
    # -----------------------------------------------------------
    # Render results
    # -----------------------------------------------------------
    output$summary_ui <- renderUI({
      render_anova_results(ns, models(), "Two-way ANOVA")
    })
    
    # -----------------------------------------------------------
    # Render model summaries + downloads (shared helper)
    # -----------------------------------------------------------
    bind_anova_outputs(ns, output, models)

    anova_results <- reactive({
      mod <- models()
      req(mod)

      res <- compile_anova_results(mod)
      data_used <- mod$data_used

      list(
        analysis_type = "ANOVA",
        type = "twoway_anova",
        data_used = data_used,
        model = mod$models,
        summary = res$summary,
        posthoc = res$posthoc,
        effects = res$effects,
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        metadata = list(
          responses = mod$responses,
          strata = mod$strata,
          factors = mod$factors,
          orders = mod$orders,
          errors = res$errors
        ),
        models = mod$models,
        responses = mod$responses,
        strata = mod$strata,
        factors = mod$factors,
        orders = mod$orders
      )
    })

    return(anova_results)
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Two-way ANOVA (Simplified & Consistent)
# ===============================================================

visualize_twoway_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize two-way ANOVA"),
      p("Select visualization type and adjust subplot layout, axis scaling, and figure size."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Lineplots (mean Â± SE)" = "lineplot_mean_se",
            "Barplots (mean Â± SE)"  = "barplot_mean_se"
          ),
          selected = "lineplot_mean_se"
        ),
        "Pick the chart style you prefer for viewing group means and uncertainty."
      ),
      uiOutput(ns("layout_controls")),
      conditionalPanel(
        condition = sprintf("input['%s'] === 'barplot_mean_se'", ns("plot_type")),
        with_help_tooltip(
          checkboxInput(
            ns("show_bar_labels"),
            "Show value labels on bars",
            value = FALSE
          ),
          "Turn on labels to display the mean value on each bar."
        )
      ),
      fluidRow(
        column(6, with_help_tooltip(
          numericInput(ns("plot_width"),  "Subplot width (px)",  value = 400, min = 200, max = 1200, step = 50),
          "Set how wide each subplot should be in pixels."
        )),
        column(6, with_help_tooltip(
          numericInput(ns("plot_height"), "Subplot height (px)", value = 300, min = 200, max = 1200, step = 50),
          "Set how tall each subplot should be in pixels."
        ))
      ),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(6, base_size_ui(
          ns,
          default = 14,
          help_text = "Adjust the base font size used for the ANOVA plots."
        ))
      ),
      br(),
      with_help_tooltip(
        downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
        "Save the current figure as an image file."
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_twoway_server <- function(id, filtered_data, model_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(filtered_data())

    # ---- Plug in color customization module (multi-color mode) ----
    color_var_reactive <- reactive({
      info <- model_info()
      if (is.null(info) || is.null(info$factors)) return(NULL)
      info$factors$factor2
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = df,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 14
    )

    cached_results <- reactiveValues(plots = list())

    plot_types <- c("lineplot_mean_se", "barplot_mean_se")

    compute_empty_result <- function(message = NULL) {
      list(
        plot = NULL,
        warning = message,
        layout = NULL,
        defaults = NULL
      )
    }

    empty_results <- function(message) {
      setNames(rep(list(compute_empty_result(message)), length(plot_types)), plot_types)
    }

    extract_or <- function(x, name, default) {
      if (is.null(x)) return(default)
      value <- x[[name]]
      if (is.null(value)) default else value
    }

    update_layout_inputs <- function(section, rows_id, cols_id) {
      if (is.null(section)) return()
      rows <- section$rows
      cols <- section$cols
      if (!is.null(rows)) {
        sync_numeric_input(session, rows_id, input[[rows_id]], rows)
      }
      if (!is.null(cols)) {
        sync_numeric_input(session, cols_id, input[[cols_id]], cols)
      }
    }

    compute_all_plots <- function(data, info, layout_inputs, colors, base_size_value) {
      if (is.null(info)) {
        return(list())
      }

      if (!identical(info$type, "twoway_anova")) {
        return(empty_results("No two-way ANOVA results available for plotting."))
      }

      if (is.null(data) || nrow(data) == 0) {
        return(empty_results("No data available for plotting."))
      }

      safe_plot <- function(expr) {
        tryCatch({
          result <- expr
          if (is.null(result)) {
            compute_empty_result("Unable to generate plot.")
          } else {
            result
          }
        }, error = function(e) {
          compute_empty_result(e$message)
        })
      }

      line_colors <- if (length(colors) == 0) NULL else colors

      posthoc_data <- tryCatch(
        compile_anova_results(info)$posthoc,
        error = function(e) NULL
      )

      list(
        lineplot_mean_se = safe_plot(
          plot_anova_lineplot_meanse(
            data,
            info,
            layout_inputs,
            line_colors = line_colors,
            base_size = base_size_value
          )
        ),
        barplot_mean_se = safe_plot(
          plot_anova_barplot_meanse(
            data,
            info,
            layout_values = layout_inputs,
            line_colors = line_colors,
            posthoc_all = posthoc_data,
            show_value_labels = isTRUE(input$show_bar_labels),
            base_size = base_size_value
          )
        )
      )
    }

    observeEvent(
      list(
        model_info(),
        df(),
        input$strata_rows,
        input$strata_cols,
        input$resp_rows,
        input$resp_cols,
        custom_colors(),
        base_size(),
        input$show_bar_labels
      ),
      {
        info <- model_info()
        data <- df()
        layout_inputs <- list(
          strata_rows = input$strata_rows,
          strata_cols = input$strata_cols,
          resp_rows = input$resp_rows,
          resp_cols = input$resp_cols
        )

        cached_results$plots <- compute_all_plots(
          data,
          info,
          layout_inputs,
          custom_colors(),
          base_size()
        )
      },
      ignoreNULL = FALSE
    )

    results <- reactive(cached_results$plots)

    current_result <- reactive({
      res <- results()
      if (!length(res)) return(NULL)
      res[[input$plot_type]]
    })

    plot_obj <- reactive({
      info <- current_result()
      if (is.null(info) || !is.null(info$warning)) return(NULL)
      info$plot
    })

    plot_size <- reactive({
      res <- current_result()
      layout <- if (is.null(res)) list() else extract_or(res, "layout", list())
      strata_layout <- extract_or(layout, "strata", list(rows = 1, cols = 1))
      response_layout <- extract_or(layout, "responses", list(rows = 1, cols = 1))
      strata_rows <- extract_or(strata_layout, "rows", 1)
      strata_cols <- extract_or(strata_layout, "cols", 1)
      resp_rows <- extract_or(response_layout, "rows", 1)
      resp_cols <- extract_or(response_layout, "cols", 1)
      list(
        w = input$plot_width * strata_cols * resp_cols,
        h = input$plot_height * strata_rows * resp_rows
      )
    })

    observeEvent(results(), {
      res_list <- results()
      if (!length(res_list)) return()

      valid <- Filter(function(item) !is.null(item$defaults) && !is.null(item$layout), res_list)
      if (!length(valid)) return()

      defaults <- valid[[1]]$defaults
      update_layout_inputs(defaults$strata, "strata_rows", "strata_cols")
      update_layout_inputs(defaults$responses, "resp_rows", "resp_cols")
    }, ignoreNULL = FALSE)

    output$layout_controls <- renderUI({
      info <- model_info()
      req(info)
      build_anova_layout_controls(ns, input, info)
    })

    output$plot_warning <- renderUI({
      info <- current_result()
      if (is.null(info) || is.null(info$warning)) return(NULL)
      div(class = "alert alert-warning", HTML(info$warning))
    })

    output$plot <- renderPlot({
      plot <- plot_obj()
      req(plot)
      plot
    },
    width = function() plot_size()$w,
    height = function() plot_size()$h,
    res = 96)

    output$download_plot <- downloadHandler(
      filename = function() paste0("anova_plot_", Sys.Date(), ".png"),
      content = function(file) {
        info <- current_result()
        req(info)
        req(is.null(info$warning))
        plot <- plot_obj()
        req(plot)
        size <- plot_size()
        ggsave(
          filename = file,
          plot = plot,
          device = "png",
          dpi = 300,
          width = size$w / 96,
          height = size$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}
# ===============================================================
# ðŸŽ¨ Compact dropdown-style color picker (4x4 grid)
# ===============================================================

# ---- Palette ----
basic_color_palette <- c(
  "steelblue" = "#4682B4",
  "red"       = "#FF0000",
  "green"     = "#008000",  # âœ… web green (not ggplot's neon)
  "blue"      = "#0000FF",
  "orange"    = "#FFA500",
  "purple"    = "#800080",
  "brown"     = "#A52A2A",
  "gold"      = "#FFD700",
  "pink"      = "#FF69B4",
  "cyan"      = "#00FFFF",
  "magenta"   = "#FF00FF",
  "yellow"    = "#FFFF00",
  "black"     = "#000000",
  "gray"      = "#808080",
  "darkgreen" = "#006400",
  "darkred"   = "#8B0000"
)

# ---- UI Helper ----
color_dropdown_input <- function(ns, id = "color_choice", palette = basic_color_palette,
                                 ncol = 4, selected = NULL) {
  selected_color <- if (is.null(selected)) palette[1] else selected

  cell_size <- 26
  gap_size <- 4
  padding_size <- 3
  button_size <- cell_size + (2 * padding_size)
  button_height <- button_size
  dropdown_width <- cell_size * ncol + gap_size * (ncol - 1) + 2 * padding_size
  dropdown_top <- button_height + 4

  tagList(
    tags$style(HTML(sprintf("
        .color-dropdown {
          position: relative;
          display: inline-block;
          user-select: none;
          width: %dpx;
        }
        .color-dropdown-button {
          width: 100%%;
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: %dpx;
          background-color: #fff;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .color-dropdown-swatch {
          flex: 0 0 %dpx;
          width: %dpx;
          height: %dpx;
          border-radius: 4px;
          border: 1px solid #ccc;
          box-sizing: border-box;
        }
        .color-dropdown-grid {
          display: none;
          position: absolute;
          top: %dpx;
          left: 0;
          z-index: 999;
          background: #fff;
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: %dpx;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
          width: %dpx;
          grid-template-columns: repeat(%d, %dpx);
          gap: %dpx;
          box-sizing: border-box;
        }
        .color-dropdown-grid.open {
          display: grid;
        }
        .color-cell {
          width: %dpx;
          height: %dpx;
          border-radius: 4px;
          cursor: pointer;
          border: 1px solid #ccc;
          box-sizing: border-box;
          transition: transform 0.1s ease;
        }
        .color-cell:hover {
          transform: scale(1.05);
        }
      ",
      button_size, padding_size, cell_size, cell_size, cell_size,
      dropdown_top, padding_size, dropdown_width, ncol, cell_size, gap_size,
      cell_size, cell_size
    ))),
    tags$div(
      class = "color-dropdown",
      tags$div(
        id = ns(paste0(id, "_button")),
        class = "color-dropdown-button",
        tags$span(
          class = "color-dropdown-swatch",
          style = sprintf("background-color:%s;", selected_color)
        )
      ),
      tags$div(
        id = ns(paste0(id, "_grid")),
        class = "color-dropdown-grid",
        lapply(names(palette), function(col_name) {
          hex <- palette[[col_name]]
          tags$div(
            class = "color-cell",
            title = col_name,  # tooltip shows readable color name
            style = sprintf("background-color:%s;", hex),
            onclick = sprintf(
              "
      var button = $('#%s_button');
      button.find('.color-dropdown-swatch').css('background-color','%s');
      $('#%s_grid').removeClass('open');
      Shiny.setInputValue('%s','%s',{priority:'event'});
      ",
              ns(id), hex, ns(id), ns(id), hex
            )
          )
        })
        
      )
    ),
    tags$script(HTML(sprintf("
        $('#%s_button').on('click', function(e){
          e.stopPropagation();
          var grid = $('#%s_grid');
          $('.color-dropdown-grid').not(grid).removeClass('open');
          grid.toggleClass('open');
        });
        $(document).on('click', function(){
          $('.color-dropdown-grid').removeClass('open');
        });
        Shiny.setInputValue('%s','%s',{priority:'event'});
      ",
      ns(id), ns(id), ns(id), selected_color
    )))
  )
}

# ===============================================================
# ðŸ›ˆ Consistent tooltip helper for UI widgets
# ===============================================================

with_help_tooltip <- function(widget, text) {
  tags$div(
    class = "ta-help-tooltip",
    title = text,
    widget
  )
}
# ===============================================================
# ðŸ§¾ Table Analyzer â€” Descriptive Statistics Modules
# ===============================================================

descriptive_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      uiOutput(ns("inputs")),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show summary", width = "100%"),
          "Calculate the descriptive statistics for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_summary"), "Download summary", style = "width: 100%;"),
          "Save the displayed summary as a text file for later reference."
        ))
      ),
      hr()
    ),
    results = tagList(
      verbatimTextOutput(ns("summary_text"))
    )
  )
}

descriptive_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- filtered_data

    # ------------------------------------------------------------
    # Dynamic inputs
    # ------------------------------------------------------------
    output$inputs <- renderUI({
      req(df())
      data <- df()
      cat_cols <- names(data)[vapply(data, function(x) is.character(x) || is.factor(x) || is.logical(x), logical(1))]
      num_cols <- names(data)[vapply(data, is.numeric, logical(1))]
      
      tagList(
        with_help_tooltip(
          selectInput(ns("cat_vars"), label = "Categorical variables", choices = cat_cols, selected = cat_cols, multiple = TRUE),
          "Choose the group variables whose counts and proportions you want to inspect."
        ),
        with_help_tooltip(
          selectInput(ns("num_vars"), label = "Numeric variables", choices = num_cols, selected = num_cols, multiple = TRUE),
          "Choose the numeric measurements you want to summarise (mean, SD, etc.)."
        )
      )
    })
    
    strat_info <- stratification_server("strat", df)
    
    # ------------------------------------------------------------
    # Summary computation
    # ------------------------------------------------------------
    summary_data <- eventReactive(input$run, {
      req(df())
      
      local_data <- df()
      selected_vars <- unique(c(input$cat_vars, input$num_vars))
      
      validate(
        need(length(selected_vars) > 0, "Please select at least one variable.")
      )
      
      strat_details <- strat_info()
      group_var <- strat_details$var
      data_columns <- selected_vars
      
      # --- Handle stratification if present ---
      if (!is.null(group_var)) {
        sel <- strat_details$levels
        if (!is.null(sel) && length(sel) > 0) {
          local_data <- dplyr::filter(local_data, .data[[group_var]] %in% sel)
          local_data[[group_var]] <- factor(as.character(local_data[[group_var]]), levels = sel)
        } else {
          local_data[[group_var]] <- factor(as.character(local_data[[group_var]]))
        }
        local_data <- droplevels(local_data)
        data_columns <- unique(c(data_columns, group_var))
      }
      
      # --- Keep only selected valid columns ---
      data_columns <- data_columns[!is.na(data_columns) & nzchar(data_columns)]
      data_columns <- intersect(data_columns, names(local_data))
      local_data <- local_data[, data_columns, drop = FALSE]
      
      # --- Identify strata levels (if any) ---
      strata_levels <- if (!is.null(group_var) && group_var %in% names(local_data)) {
        levels(local_data[[group_var]])
      } else {
        NULL
      }
      
      # --- Compute summary ---
      list(
        summary = compute_descriptive_summary(local_data, group_var),
        selected_vars = selected_vars,
        group_var = group_var,
        processed_data = local_data,
        strata_levels = strata_levels
      )
    })
    
    
    
    
    # ------------------------------------------------------------
    # Print summary
    # ------------------------------------------------------------
    output$summary_text <- renderPrint({
      req(summary_data())
      print_summary_sections(summary_data()$summary)
    })
    
    # ------------------------------------------------------------
    # Download
    # ------------------------------------------------------------
    output$download_summary <- downloadHandler(
      filename = function() paste0("Descriptive_Statistics_", Sys.Date(), ".txt"),
      content = function(file) {
        results <- summary_data()
        req(results)
        sink(file)
        on.exit(sink(), add = TRUE)
        print_summary_sections(results$summary)
      }
    )
    
    # ------------------------------------------------------------
    # Return full model info
    # ------------------------------------------------------------
    df_final <- reactive({
      details <- summary_data()
      req(details)
      details$processed_data
    })

    model_fit <- reactive(NULL)

    summary_table <- reactive({
      details <- summary_data()
      req(details)
      details$summary
    })

    posthoc_results <- reactive(NULL)

    effect_table <- reactive(NULL)

    selected_vars_reactive <- reactive({
      details <- summary_data()
      req(details)
      details$selected_vars
    })

    group_var_reactive <- reactive({
      details <- summary_data()
      req(details)
      details$group_var
    })

    strata_levels_reactive <- reactive({
      details <- summary_data()
      req(details)
      details$strata_levels
    })

    reactive({
      details <- summary_data()
      req(details)

      data_used <- df_final()

      list(
        analysis_type = "DESCRIPTIVE",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = posthoc_results(),
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        metadata = list(
          selected_vars = details$selected_vars,
          group_var = details$group_var,
          strata_levels = details$strata_levels
        ),
        type = "descriptive",
        data = df,
        processed_data = df_final,
        selected_vars = selected_vars_reactive,
        group_var = group_var_reactive,
        strata_levels = strata_levels_reactive
      )
    })

  })
}

compute_descriptive_summary <- function(data, group_var = NULL) {
  numeric_vars <- names(data)[sapply(data, is.numeric)]
  
  group_data <- if (!is.null(group_var)) group_by(data, .data[[group_var]], .drop = TRUE) else data
  
  skim_out <- if (!is.null(group_var)) {
    group_data %>% skim()
  } else {
    skim(data)
  }
  
  cv_out <- group_data %>%
    summarise(across(
      where(is.numeric),
      ~ 100 * sd(.x, na.rm = TRUE) / mean(.x, na.rm = TRUE),
      .names = "cv_{.col}"
    ), .groups = "drop")
  
  outlier_out <- group_data %>%
    summarise(across(
      all_of(numeric_vars),
      ~ {
        q <- quantile(.x, probs = c(0.25, 0.75), na.rm = TRUE)
        iqr <- q[2] - q[1]
        sum(.x < q[1] - 1.5 * iqr | .x > q[2] + 1.5 * iqr, na.rm = TRUE)
      },
      .names = "outliers_{.col}"
    ), .groups = "drop")
  
  missing_out <- group_data %>%
    summarise(across(
      all_of(numeric_vars),
      ~ 100 * mean(is.na(.x)),
      .names = "missing_{.col}"
    ), .groups = "drop")
  
  shapiro_out <- group_data %>%
    summarise(across(
      all_of(numeric_vars),
      ~ tryCatch(shapiro.test(.x)$p.value, error = function(e) NA_real_),
      .names = "shapiro_{.col}"
    ), .groups = "drop")
  
  list(
    skim = skim_out,
    cv = cv_out,
    outliers = outlier_out,
    missing = missing_out,
    shapiro = shapiro_out
  )
}

# ---- Shared printing ----
print_summary_sections <- function(results) {
  # 1) Print skim AS-IS (unchanged)
  cat(paste(capture.output(print(results$skim)), collapse = "\n"), "\n\n", sep = "")
  
  # 2) Helper to detect if a grouping column exists and what it's called
  metric_prefix <- "^(cv_|outliers_|missing_|shapiro_)"
  first_col <- if (!is.null(results$cv) && ncol(results$cv) > 0) names(results$cv)[1] else NULL
  group_col <- if (!is.null(first_col) && !grepl(metric_prefix, first_col)) first_col else NULL
  
  # 3) Robust long conversion that preserves the real group column name (if any)
  to_long <- function(df, value_name, group_col) {
    if (is.null(df) || ncol(df) == 0) {
      if (is.null(group_col)) {
        return(tibble::tibble(variable = character(), !!value_name := numeric()))
      } else {
        return(tibble::tibble(!!group_col := character(), variable = character(), !!value_name := numeric()))
      }
    }
    if (is.null(group_col)) {
      out <- tidyr::pivot_longer(df, tidyselect::everything(),
                                 names_to = "variable", values_to = value_name)
    } else {
      out <- tidyr::pivot_longer(df, -dplyr::all_of(group_col),
                                 names_to = "variable", values_to = value_name)
    }
    out$variable <- sub("^(cv_|outliers_|missing_|shapiro_)", "", out$variable)
    out
  }
  
  # 4) Build pieces (no "missing" here)
  cv_long   <- to_long(results$cv,       "cv",        group_col)
  out_long  <- to_long(results$outliers, "outliers",  group_col)
  shap_long <- to_long(results$shapiro,  "shapiro_p", group_col)
  
  # 5) Join by the right keys
  if (is.null(group_col)) {
    merged <- dplyr::full_join(cv_long,  out_long,  by = "variable") |>
      dplyr::full_join(shap_long, by = "variable")
  } else {
    merged <- dplyr::full_join(cv_long,  out_long,  by = c(group_col, "variable")) |>
      dplyr::full_join(shap_long, by = c(group_col, "variable"))
  }
  
  # 6) Round / order by numeric skim order
  merged <- merged |>
    dplyr::mutate(
      cv = round(cv, 2),
      shapiro_p = signif(shapiro_p, 3)
    )
  
  numeric_order <- NULL
  if (is.data.frame(results$skim) &&
      all(c("skim_type", "skim_variable") %in% names(results$skim))) {
    numeric_order <- results$skim |>
      dplyr::filter(.data$skim_type == "numeric") |>
      dplyr::pull(.data$skim_variable) |>
      unique()
  }
  if (!is.null(numeric_order) && length(numeric_order) > 0) {
    merged$variable <- factor(merged$variable, levels = numeric_order)
    if (is.null(group_col)) {
      merged <- dplyr::arrange(merged, .data$variable)
    } else {
      merged <- dplyr::arrange(merged, .data[[group_col]], .data$variable)
    }
    merged$variable <- as.character(merged$variable)
  } else {
    if (is.null(group_col)) {
      merged <- dplyr::arrange(merged, .data$variable)
    } else {
      merged <- dplyr::arrange(merged, .data[[group_col]], .data$variable)
    }
  }
  
  # 7) Print with/without group column
  cat("â”€â”€ Numeric variables summary â”€â”€\n")
  if (is.null(group_col)) {
    final_df <- merged[, c("variable","cv","outliers","shapiro_p"), drop = FALSE]
  } else {
    final_df <- merged[, c("variable", group_col, "cv","outliers","shapiro_p"), drop = FALSE]
  }
  print(as.data.frame(final_df), row.names = FALSE)
  
  cat("\nInterpretation:\n")
  cat("  â€¢ outliers = # beyond 1.5Ã—IQR\n")
  cat("  â€¢ shapiro_p < 0.05 â†’ non-normal distribution\n")
  
  invisible(NULL)
}
# ===============================================================
# Visualization Module â€” Descriptive Statistics (Dispatcher)
# ===============================================================

visualize_descriptive_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 5 â€” Visualize descriptive statistics"),
      p("Explore distributions, variability, and normality across variables."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c(
            "Categorical barplots" = "categorical",
            "Numeric boxplots"          = "boxplots",
            "Numeric histograms"        = "histograms",
            "CV (%)"                    = "cv",
            "Outlier counts"            = "outliers",
            "Missingness (%)"           = "missing"
          ),
          selected = "categorical"
        ),
        "Choose the descriptive chart that best answers your question."
      ),
      uiOutput(ns("sub_controls"))  # controls from active submodule
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_ui"))  # plot output provided by the active submodule
    )
  )
}


visualize_descriptive_server <- function(id, filtered_data, descriptive_summary) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    active_type <- reactive({
      type <- input$plot_type
      if (is.null(type) || !nzchar(type[1])) "categorical" else type[1]
    })
    

    # ==========================================================
    # ðŸ”¹ Inject the correct UI for each submodule
    # ==========================================================
    output$sub_controls <- renderUI({
      type <- active_type()
      switch(type,
             "categorical" = visualize_categorical_barplots_ui(ns("categorical")),
             "boxplots"    = visualize_numeric_boxplots_ui(ns("boxplots")),
             "histograms"  = visualize_numeric_histograms_ui(ns("histograms")),
             "cv"          = visualize_cv_ui(ns("cv")),
             "outliers"    = visualize_outliers_ui(ns("outliers")),
             "missing"     = visualize_missing_ui(ns("missing")),
             div("No controls available for this plot type.")
      )
    })

    output$plot_ui <- renderUI({
      type <- active_type()
      switch(type,
             "categorical" = visualize_categorical_barplots_plot_ui(ns("categorical")),
             "boxplots"    = visualize_numeric_boxplots_plot_ui(ns("boxplots")),
             "histograms"  = visualize_numeric_histograms_plot_ui(ns("histograms")),
             "cv"          = visualize_cv_plot_ui(ns("cv")),
             "outliers"    = visualize_outliers_plot_ui(ns("outliers")),
             "missing"     = visualize_missing_plot_ui(ns("missing")),
             div("Plot not available for this selection.")
      )
    })

    categorical_active <- reactive(active_type() == "categorical")
    boxplots_active    <- reactive(active_type() == "boxplots")
    histograms_active  <- reactive(active_type() == "histograms")
    cv_active          <- reactive(active_type() == "cv")
    outliers_active    <- reactive(active_type() == "outliers")
    missing_active     <- reactive(active_type() == "missing")

    visualize_categorical_barplots_server(
      "categorical",
      filtered_data,
      descriptive_summary,
      is_active = categorical_active
    )
    visualize_numeric_boxplots_server(
      "boxplots",
      filtered_data,
      descriptive_summary,
      is_active = boxplots_active
    )
    visualize_numeric_histograms_server(
      "histograms",
      filtered_data,
      descriptive_summary,
      is_active = histograms_active
    )
    visualize_cv_server(
      "cv",
      filtered_data,
      descriptive_summary,
      is_active = cv_active
    )
    visualize_outliers_server(
      "outliers",
      filtered_data,
      descriptive_summary,
      is_active = outliers_active
    )
    visualize_missing_server(
      "missing",
      filtered_data,
      descriptive_summary,
      is_active = missing_active
    )
  })
}
# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Categorical Barplots
# ===============================================================

visualize_categorical_barplots_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("show_proportions"), "Show proportions instead of counts", FALSE),
      "Switch between raw counts and percentages for each category."
    ),
    with_help_tooltip(
      checkboxInput(ns("show_value_labels"), "Show value labels on bars", FALSE),
      "Display the numeric value on top of each bar."
    ),
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("plot_width"),  "Subplot width (px)",  400, 200, 2000, 50),
        "Set the width of each categorical plot in pixels."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("plot_height"), "Subplot height (px)", 300, 200, 2000, 50),
        "Set the height of each categorical plot in pixels."
      ))
    ),
    fluidRow(
      column(
        6,
        with_help_tooltip(
          numericInput(
            ns("resp_rows"),
            "Grid rows",
            value = NA,
            min = 1,
            max = 10,
            step = 1
          ),
          "Choose how many rows of plots to display when several charts are shown."
        )
      ),
      column(
        6,
        with_help_tooltip(
          numericInput(
            ns("resp_cols"),
            "Grid columns",
            value = NA,
            min = 1,
            max = 10,
            step = 1
          ),
          "Choose how many columns of plots to display when several charts are shown."
        )
      )
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 13,
        help_text = "Adjust the base font size used for barplot text elements."
      ))
    ),
    hr(),
    with_help_tooltip(
      downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
      "Save the categorical barplots as an image file."
    )
  )
}

visualize_categorical_barplots_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    class = "ta-plot-container",
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}

visualize_categorical_barplots_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    resolve_input_value <- function(x) {
      if (is.null(x)) return(NULL)
      if (is.reactive(x)) x() else x
    }

    module_active <- reactive({
      if (is.null(is_active)) {
        TRUE
      } else {
        isTRUE(is_active())
      }
    })

    plot_width <- reactive({
      w <- input$plot_width
      if (is.null(w) || !is.numeric(w) || is.na(w)) 400 else w
    })

    plot_height <- reactive({
      h <- input$plot_height
      if (is.null(h) || !is.numeric(h) || is.na(h)) 300 else h
    })
    
    color_var_reactive <- reactive({
      info <- summary_info()
      if (is.null(info)) return(NULL)

      group_var <- resolve_input_value(info$group_var)
      if (is.null(group_var) || identical(group_var, "") || identical(group_var, "None")) {
        return(NULL)
      }

      dat <- filtered_data()
      if (is.null(dat) || !is.data.frame(dat) || !group_var %in% names(dat)) {
        return(NULL)
      }

      group_var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = filtered_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 13
    )

    cached_plot_info <- reactiveVal(NULL)
    cache_ready <- reactiveVal(FALSE)

    invalidate_cache <- function() {
      cached_plot_info(NULL)
      cache_ready(FALSE)
      invisible(TRUE)
    }

    observeEvent(
      list(
        summary_info(),
        filtered_data(),
        input$show_proportions,
        input$show_value_labels,
        custom_colors(),
        base_size()
      ),
      {
        invalidate_cache()
      },
      ignoreNULL = FALSE
    )

    observeEvent(input$resp_rows, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_rows"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    observeEvent(input$resp_cols, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_cols"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    compute_plot_info <- function() {
      info <- summary_info()

      validate(need(!is.null(info), "Summary not available."))

      processed <- resolve_input_value(info$processed_data)
      dat <- if (!is.null(processed)) processed else filtered_data()

      validate(need(!is.null(dat) && is.data.frame(dat) && nrow(dat) > 0, "No data available."))

      selected_vars <- resolve_input_value(info$selected_vars)
      group_var     <- resolve_input_value(info$group_var)
      strata_levels <- resolve_input_value(info$strata_levels)

      out <- build_descriptive_categorical_plot(
        df = dat,
        selected_vars = selected_vars,
        group_var = group_var,
        strata_levels = strata_levels,
        show_proportions = isTRUE(input$show_proportions),
        nrow_input = input$resp_rows,
        ncol_input = input$resp_cols,
        fill_colors = custom_colors(),
        show_value_labels = isTRUE(input$show_value_labels),
        base_size = base_size()
      )
      validate(need(!is.null(out), "No categorical variables available for plotting."))
      out
    }

    plot_info <- reactive({
      req(module_active())
      if (!isTRUE(cache_ready())) {
        cached_plot_info(compute_plot_info())
        cache_ready(TRUE)
      }
      cached_plot_info()
    })

    plot_size <- reactive({
      req(module_active())
      info <- plot_info()
      layout <- info$layout
      if (is.null(layout)) {
        list(w = plot_width(), h = plot_height())
      } else {
        list(
          w = plot_width()  * layout$ncol,
          h = plot_height() * layout$nrow
        )
      }
    })

    observeEvent(plot_info(), {
      info <- plot_info()
      if (is.null(info) || is.null(info$defaults)) return()

      rows <- info$defaults$rows
      cols <- info$defaults$cols
      if (is.null(rows) || is.null(cols)) return()

      sync_numeric_input(session, "resp_rows", input$resp_rows, rows)
      sync_numeric_input(session, "resp_cols", input$resp_cols, cols)
    }, ignoreNULL = FALSE)

    output$grid_warning <- renderUI({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning)) {
        div(class = "alert alert-warning", info$warning)
      } else {
        NULL
      }
    })

    output$download_plot <- downloadHandler(
      filename = function() paste0("categorical_barplots_", Sys.Date(), ".png"),
      content  = function(file) {
        req(module_active())
        info <- plot_info()
        req(is.null(info$warning))
        req(info$plot)
        s <- plot_size()
        ggplot2::ggsave(
          filename = file,
          plot = info$plot,
          device = "png",
          dpi = 300,
          width  = s$w / 96,
          height = s$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )

    output$plot <- renderPlot({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning) || is.null(info$plot)) return(NULL)
      print(info$plot)
    },
    width = function() {
      req(module_active())
      plot_size()$w
    },
    height = function() {
      req(module_active())
      plot_size()$h
    },
    res = 96)
  })
}


build_descriptive_categorical_plot <- function(df,
                                               selected_vars = NULL,
                                               group_var = NULL,
                                               strata_levels = NULL,
                                               show_proportions = FALSE,
                                               nrow_input = NULL,
                                               ncol_input = NULL,
                                               fill_colors = NULL,
                                               show_value_labels = FALSE,
                                               base_size = 13) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)
  
  factor_vars <- names(df)[vapply(df, function(x) {
    is.character(x) || is.factor(x) || is.logical(x)
  }, logical(1))]
  
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    factor_vars <- intersect(factor_vars, selected_vars)
  }
  if (length(factor_vars) == 0) return(NULL)
  
  if (!is.null(group_var) && group_var %in% names(df)) {
    df[[group_var]] <- as.character(df[[group_var]])
    df[[group_var]][is.na(df[[group_var]]) | trimws(df[[group_var]]) == ""] <- "Missing"
    
    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      keep_levels <- unique(strata_levels)
      df <- df[df[[group_var]] %in% keep_levels, , drop = FALSE]
      if (nrow(df) == 0) return(NULL)
      df[[group_var]] <- factor(df[[group_var]], levels = keep_levels)
    } else {
      df[[group_var]] <- factor(df[[group_var]], levels = unique(df[[group_var]]))
    }
  } else {
    group_var <- NULL
  }
  
  plots <- lapply(factor_vars, function(var) {
    group_col <- if (!is.null(group_var) && !identical(group_var, var)) group_var else NULL
    cols_to_use <- c(var, group_col)
    cols_to_use <- cols_to_use[cols_to_use %in% names(df)]
    var_data <- df[, cols_to_use, drop = FALSE]
    
    var_data[[var]] <- as.character(var_data[[var]])
    keep <- !is.na(var_data[[var]]) & trimws(var_data[[var]]) != ""
    if (!any(keep)) return(NULL)
    var_data <- var_data[keep, , drop = FALSE]
    
    level_order <- if (is.factor(df[[var]])) {
      as.character(levels(df[[var]]))
    } else {
      unique(var_data[[var]])
    }
    var_data[[var]] <- factor(var_data[[var]], levels = level_order)
    
    y_label <- if (isTRUE(show_proportions)) "Proportion" else "Count"
    
    if (!is.null(group_col)) {
      var_data[[group_col]] <- droplevels(var_data[[group_col]])
      count_df <- dplyr::count(var_data, .data[[var]], .data[[group_col]], name = "count")
      if (nrow(count_df) == 0) return(NULL)

      if (isTRUE(show_proportions)) {
        count_df <- count_df |>
          dplyr::group_by(.data[[group_col]]) |>
          dplyr::mutate(total = sum(.data$count, na.rm = TRUE)) |>
          dplyr::mutate(value = ifelse(.data$total > 0, .data$count / .data$total, 0)) |>
          dplyr::ungroup()
        count_df$total <- NULL
      } else {
        count_df <- dplyr::mutate(count_df, value = .data$count)
      }

      count_df[[var]] <- factor(as.character(count_df[[var]]), levels = level_order)
      group_levels <- levels(droplevels(var_data[[group_col]]))
      count_df[[group_col]] <- factor(as.character(count_df[[group_col]]), levels = group_levels)

      palette <- resolve_palette_for_levels(group_levels, custom = fill_colors)
      group_dodge <- position_dodge(width = 0.75)

      p <- ggplot(count_df, aes(x = .data[[var]], y = .data$value, fill = .data[[group_col]])) +
        geom_col(position = group_dodge, width = 0.65) +
        scale_fill_manual(values = palette) +
        theme_minimal(base_size = base_size) +
        labs(title = var, x = NULL, y = y_label, fill = group_col) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))

      if (isTRUE(show_value_labels)) {
        label_formatter <- if (isTRUE(show_proportions)) {
          scales::label_percent(accuracy = 0.1, trim = TRUE)
        } else {
          scales::label_comma(accuracy = 1, trim = TRUE)
        }

        label_df <- count_df |>
          dplyr::mutate(
            label_text = label_formatter(value),
            label_y = value,
            label_vjust = ifelse(value >= 0, -0.4, 1.2)
          )

        p <- p +
          geom_text(
            data = label_df,
            aes(
              x = .data[[var]],
              y = label_y,
              label = label_text,
              vjust = label_vjust,
              group = .data[[group_col]]
            ),
            position = group_dodge,
            color = "gray20",
            size = 3.5,
            fontface = "bold",
            inherit.aes = FALSE
          )
      }

      if (isTRUE(show_proportions)) {
        scale_args <- list(labels = scales::percent_format(accuracy = 1))
        if (isTRUE(show_value_labels)) {
          scale_args$limits <- c(0, NA)
          scale_args$expand <- expansion(mult = c(0.02, 0.12))
        } else {
          scale_args$limits <- c(0, 1)
        }
        p <- p + do.call(scale_y_continuous, scale_args)
      } else if (isTRUE(show_value_labels)) {
        p <- p + scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0.05, 0.12)))
      }

      p
    } else {
      count_df <- dplyr::count(var_data, .data[[var]], name = "count")
      if (nrow(count_df) == 0) return(NULL)

      total <- sum(count_df$count, na.rm = TRUE)
      if (isTRUE(show_proportions) && total > 0) {
        count_df$value <- count_df$count / total
      } else {
        count_df$value <- count_df$count
      }

      count_df[[var]] <- factor(as.character(count_df[[var]]), levels = level_order)

      single_fill <- if (!is.null(fill_colors) && length(fill_colors) > 0) {
        fill_colors[1]
      } else {
        resolve_single_color()
      }

      p <- ggplot(count_df, aes(x = .data[[var]], y = .data$value)) +
        geom_col(fill = single_fill, width = 0.65) +
        theme_minimal(base_size = base_size) +
        labs(title = var, x = NULL, y = y_label) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))

      if (isTRUE(show_value_labels)) {
        label_formatter <- if (isTRUE(show_proportions)) {
          scales::label_percent(accuracy = 0.1, trim = TRUE)
        } else {
          scales::label_comma(accuracy = 1, trim = TRUE)
        }

        label_df <- count_df |>
          dplyr::mutate(
            label_text = label_formatter(value),
            label_y = value,
            label_vjust = ifelse(value >= 0, -0.4, 1.2)
          )

        p <- p +
          geom_text(
            data = label_df,
            aes(x = .data[[var]], y = label_y, label = label_text, vjust = label_vjust),
            color = "gray20",
            size = 3.5,
            fontface = "bold",
            inherit.aes = FALSE
          )
      }

      if (isTRUE(show_proportions)) {
        scale_args <- list(labels = scales::percent_format(accuracy = 1))
        if (isTRUE(show_value_labels)) {
          scale_args$limits <- c(0, NA)
          scale_args$expand <- expansion(mult = c(0.02, 0.12))
        } else {
          scale_args$limits <- c(0, 1)
        }
        p <- p + do.call(scale_y_continuous, scale_args)
      } else if (isTRUE(show_value_labels)) {
        p <- p + scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0.05, 0.12)))
      }

      p
    }
  })
  
  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)
  
  n_panels <- length(plots)
  defaults <- compute_default_grid(n_panels)

  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols
  )

  layout <- adjust_grid_layout(n_panels, layout)

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)

  combined <- NULL
  if (isTRUE(validation$valid)) {
    combined <- patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol) +
      patchwork::plot_annotation(
        theme = theme(plot.title = element_text(size = 16, face = "bold"))
      )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}

# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Summary Metrics
# ===============================================================

# ---- UI helpers ----
metric_panel_ui <- function(id, default_width = 400, default_height = 300,
                            default_rows = 1, default_cols = 1) {
  ns <- NS(id)
  tagList(
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("plot_width"),  "Subplot width (px)",  default_width, 200, 2000, 50),
        "Set the width of each metric panel in pixels."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("plot_height"), "Subplot height (px)", default_height, 200, 2000, 50),
        "Set the height of each metric panel in pixels."
      ))
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 13,
        help_text = "Adjust the base font size used for metric plot text elements."
      ))
    ),
    hr(),
    with_help_tooltip(
      downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
      "Save the metric charts as an image file."
    )
  )
}


visualize_cv_ui <- function(id) {
  metric_panel_ui(id, default_width = 400, default_height = 320, default_rows = 2, default_cols = 3)
}

visualize_outliers_ui <- function(id) {
  metric_panel_ui(id, default_width = 400, default_height = 320, default_rows = 2, default_cols = 3)
}

visualize_missing_ui <- function(id) {
  metric_panel_ui(id, default_width = 400, default_height = 320, default_rows = 2, default_cols = 3)
}

metric_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    class = "ta-plot-container",
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}

visualize_cv_plot_ui <- function(id) {
  metric_plot_ui(id)
}

visualize_outliers_plot_ui <- function(id) {
  metric_plot_ui(id)
}

visualize_missing_plot_ui <- function(id) {
  metric_plot_ui(id)
}


# ---- Shared computation helpers ----
resolve_metric_input <- function(x) {
  if (is.null(x)) return(NULL)
  if (is.reactive(x)) x() else x
}

safe_cv <- function(x) {
  m <- mean(x, na.rm = TRUE)
  s <- stats::sd(x, na.rm = TRUE)
  if (!is.finite(m) || abs(m) < .Machine$double.eps) {
    return(NA_real_)
  }
  100 * s / m
}

count_outliers <- function(x) {
  q <- stats::quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  iqr <- q[2] - q[1]
  sum(x < q[1] - 1.5 * iqr | x > q[2] + 1.5 * iqr, na.rm = TRUE)
}

missing_pct <- function(x) {
  100 * mean(is.na(x))
}

prepare_metric_data <- function(data, numeric_vars, group_var, strata_levels, metric) {
  if (length(numeric_vars) == 0) {
    return(NULL)
  }

  if (is.null(group_var) || !group_var %in% names(data)) {
    group_var <- NULL
  }

  data_tbl <- tibble::as_tibble(data)

  if (!is.null(group_var)) {
    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      data_tbl[[group_var]] <- factor(as.character(data_tbl[[group_var]]), levels = strata_levels)
      data_tbl <- droplevels(data_tbl)
    }
    data_tbl <- dplyr::group_by(data_tbl, .data[[group_var]], .drop = TRUE)
  }

  summarised <- switch(
    metric,
    cv = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ safe_cv(.x),
        .names = "cv_{.col}"
      ),
      .groups = "drop"
    ),
    outliers = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ count_outliers(.x),
        .names = "outliers_{.col}"
      ),
      .groups = "drop"
    ),
    missing = dplyr::summarise(
      data_tbl,
      dplyr::across(
        dplyr::all_of(numeric_vars),
        ~ missing_pct(.x),
        .names = "missing_{.col}"
      ),
      .groups = "drop"
    ),
    stop("Unsupported metric type.")
  )

  tidy <- tidy_descriptive_metric(summarised, metric)
  if (is.null(tidy)) {
    return(NULL)
  }

  tidy$data <- tidy$data[tidy$data$variable %in% numeric_vars, , drop = FALSE]
  if (nrow(tidy$data) == 0) {
    return(NULL)
  }

  tidy$data$variable <- factor(tidy$data$variable, levels = numeric_vars)

  if (!is.null(group_var) && !is.null(strata_levels) && length(strata_levels) > 0) {
    tidy$data$.group <- factor(as.character(tidy$data$.group), levels = strata_levels)
  }

  tidy
}

tidy_descriptive_metric <- function(df, prefix) {
  if (is.null(df) || nrow(df) == 0) return(NULL)
  metric_cols <- grep(paste0("^", prefix, "_"), names(df), value = TRUE)
  if (length(metric_cols) == 0) return(NULL)
  group_cols <- setdiff(names(df), metric_cols)
  has_group <- length(group_cols) > 0
  group_label <- if (has_group) paste(group_cols, collapse = " / ") else NULL
  if (!has_group) {
    df <- df |> dplyr::mutate(.group = "Overall")
    group_cols <- ".group"
  }
  tidy <- df |>
    tidyr::unite(".group", dplyr::all_of(group_cols), sep = " / ", remove = FALSE) |>
    tidyr::pivot_longer(
      cols = dplyr::all_of(metric_cols),
      names_to = "variable",
      values_to = "value"
    ) |>
    dplyr::mutate(
      variable = gsub(paste0("^", prefix, "_"), "", .data$variable),
      value = ifelse(is.finite(.data$value), .data$value, NA_real_),
      .group = factor(.data$.group, levels = unique(.data$.group))
    ) |>
    tidyr::drop_na("value")
  if (nrow(tidy) == 0) return(NULL)
  list(data = tidy, has_group = has_group, group_label = group_label)
}


build_metric_plot <- function(metric_info,
                              y_label,
                              title,
                              custom_colors = NULL,
                              base_size = 13) {
  df <- metric_info$data
  has_group <- isTRUE(metric_info$has_group)

  if (has_group) {
    legend_title <- if (!is.null(metric_info$group_label)) metric_info$group_label else "Group"
    palette <- resolve_palette_for_levels(levels(df$.group), custom = custom_colors)
    p <- ggplot(df, aes(x = variable, y = value, fill = .group)) +
      geom_col(position = position_dodge(width = 0.7), width = 0.65) +
      scale_fill_manual(values = palette) +
      labs(fill = legend_title)
  } else {
    p <- ggplot(df, aes(x = variable, y = value)) +
      geom_col(width = 0.65, fill = resolve_single_color(custom_colors)) +
      guides(fill = "none")
  }
  
  p +
    theme_minimal(base_size = base_size) +
    labs(x = NULL, y = y_label, title = title) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.minor = element_blank()
    )
}


metric_module_server <- function(id, filtered_data, summary_info, metric_key,
                                 y_label, title, filename_prefix, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    plot_width <- reactive({
      w <- input$plot_width
      if (is.null(w) || !is.numeric(w) || is.na(w)) 400 else w
    })

    plot_height <- reactive({
      h <- input$plot_height
      if (is.null(h) || !is.numeric(h) || is.na(h)) 300 else h
    })

    module_active <- reactive({
      if (is.null(is_active)) {
        TRUE
      } else {
        isTRUE(is_active())
      }
    })

    color_var_reactive <- reactive({
      info <- summary_info()
      if (is.null(info)) return(NULL)

      group_var <- resolve_metric_input(info$group_var)
      if (is.null(group_var) || identical(group_var, "") || identical(group_var, "None")) {
        return(NULL)
      }

      dat <- filtered_data()
      if (is.null(dat) || !is.data.frame(dat) || !group_var %in% names(dat)) {
        return(NULL)
      }

      group_var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = filtered_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 13
    )

    cached_plot_details <- reactiveVal(NULL)
    cache_ready <- reactiveVal(FALSE)

    invalidate_cache <- function() {
      cached_plot_details(NULL)
      cache_ready(FALSE)
    }

    observeEvent(
      list(
        summary_info(),
        filtered_data(),
        custom_colors(),
        base_size()
      ),
      {
        invalidate_cache()
      },
      ignoreNULL = FALSE
    )

    compute_plot_details <- function() {
      info <- summary_info()
      validate(need(!is.null(info), "Summary not available."))

      processed <- resolve_metric_input(info$processed_data)
      dat <- if (!is.null(processed)) processed else filtered_data()

      validate(need(!is.null(dat) && is.data.frame(dat) && nrow(dat) > 0, "No data available."))

      selected_vars <- resolve_metric_input(info$selected_vars)
      group_var <- resolve_metric_input(info$group_var)
      strata_levels <- resolve_metric_input(info$strata_levels)
      group_label <- resolve_metric_input(info$group_label)

      numeric_vars <- names(dat)[vapply(dat, is.numeric, logical(1))]
      if (!is.null(selected_vars) && length(selected_vars) > 0) {
        # Preserve the order specified in the UI while filtering to numeric columns.
        numeric_vars <- selected_vars[selected_vars %in% numeric_vars]
      }
      validate(need(length(numeric_vars) > 0, "No numeric variables available for plotting."))

      metric_info <- prepare_metric_data(
        data = dat,
        numeric_vars = numeric_vars,
        group_var = group_var,
        strata_levels = strata_levels,
        metric = metric_key
      )

      validate(need(!is.null(metric_info), "Unable to compute metric for the selected variables."))

      if (!is.null(group_label)) {
        metric_info$group_label <- group_label
      }

      list(
        plot = build_metric_plot(
          metric_info,
          y_label,
          title,
          custom_colors = custom_colors(),
          base_size = base_size()
        )
      )
    }

    plot_details <- reactive({
      req(module_active())
      if (!isTRUE(cache_ready())) {
        cached_plot_details(compute_plot_details())
        cache_ready(TRUE)
      }
      cached_plot_details()
    })

    plot_size <- reactive({
      req(module_active())
      list(w = plot_width(), h = plot_height())
    })

    output$download_plot <- downloadHandler(
      filename = function() paste0(filename_prefix, "_", Sys.Date(), ".png"),
      content = function(file) {
        req(module_active())
        details <- plot_details()
        req(details$plot)
        size <- plot_size()
        ggplot2::ggsave(
          filename = file,
          plot = details$plot,
          device = "png",
          dpi = 300,
          width = size$w / 96,
          height = size$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )

    output$plot <- renderPlot({
      req(module_active())
      details <- plot_details()
      if (!is.null(details$warning) || is.null(details$plot)) return(NULL)
      print(details$plot)
    },
    width = function() {
      req(module_active())
      plot_size()$w
    },
    height = function() {
      req(module_active())
      plot_size()$h
    },
    res = 96)
  })
}


visualize_cv_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  metric_module_server(
    id = id,
    filtered_data = filtered_data,
    summary_info = summary_info,
    metric_key = "cv",
    y_label = "CV (%)",
    title = "",
    filename_prefix = "cv_summary",
    is_active = is_active
  )
}

visualize_outliers_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  metric_module_server(
    id = id,
    filtered_data = filtered_data,
    summary_info = summary_info,
    metric_key = "outliers",
    y_label = "Outlier Count",
    title = "",
    filename_prefix = "outlier_summary",
    is_active = is_active
  )
}

visualize_missing_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  metric_module_server(
    id = id,
    filtered_data = filtered_data,
    summary_info = summary_info,
    metric_key = "missing",
    y_label = "Missing (%)",
    title = "",
    filename_prefix = "missing_summary",
    is_active = is_active
  )
}
# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Numeric Boxplots
# ===============================================================

visualize_numeric_boxplots_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("show_points"), "Show individual data points", TRUE),
      "Add the raw observations on top of each boxplot."
    ),
    with_help_tooltip(
      checkboxInput(ns("show_outliers"), "Highlight boxplot outliers", FALSE),
      "Highlight points that fall outside the typical range."
    ),
    conditionalPanel(
      condition = sprintf("input['%s']", ns("show_outliers")),
      uiOutput(ns("outlier_label_ui"))
    ),
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("plot_width"),  "Subplot width (px)",  200, 200, 2000, 50),
        "Control how wide each boxplot panel should be."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("plot_height"), "Subplot height (px)", 800, 200, 2000, 50),
        "Control how tall each boxplot panel should be."
      ))
    ),
    fluidRow(
      column(
        6,
        with_help_tooltip(
          numericInput(
            ns("resp_rows"),
            "Grid rows",
            value = NA,
            min = 1,
            max = 10,
            step = 1
          ),
          "Choose how many rows of plots to display when multiple charts are shown."
        )
      ),
      column(
        6,
        with_help_tooltip(
          numericInput(
            ns("resp_cols"),
            "Grid columns",
            value = NA,
            min = 1,
            max = 100,
            step = 1
          ),
          "Choose how many columns of plots to display when multiple charts are shown."
        )
      )
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 13,
        help_text = "Adjust the base font size used for boxplot text elements."
      ))
    ),
    hr(),
    with_help_tooltip(
      downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
      "Save the boxplots as an image file."
    )
  )
}


visualize_numeric_boxplots_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    class = "ta-plot-container",
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}


visualize_numeric_boxplots_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    resolve_input_value <- function(x) {
      if (is.null(x)) return(NULL)
      if (is.reactive(x)) x() else x
    }

    module_active <- reactive({
      if (is.null(is_active)) {
        TRUE
      } else {
        isTRUE(is_active())
      }
    })

    plot_width <- reactive({
      w <- input$plot_width
      if (is.null(w) || !is.numeric(w) || is.na(w)) 400 else w
    })

    plot_height <- reactive({
      h <- input$plot_height
      if (is.null(h) || !is.numeric(h) || is.na(h)) 300 else h
    })

    color_var_reactive <- reactive({
      info <- summary_info()
      if (is.null(info)) return(NULL)

      group_var <- resolve_input_value(info$group_var)
      if (is.null(group_var) || identical(group_var, "") || identical(group_var, "None")) {
        return(NULL)
      }

      dat <- filtered_data()
      if (is.null(dat) || !is.data.frame(dat) || !group_var %in% names(dat)) {
        return(NULL)
      }

      group_var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = filtered_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 13
    )

    output$outlier_label_ui <- renderUI({
      dat <- filtered_data()
      cat_cols <- character(0)
      if (!is.null(dat) && is.data.frame(dat)) {
        cat_cols <- names(dat)[vapply(
          dat,
          function(x) is.character(x) || is.factor(x) || is.logical(x),
          logical(1)
        )]
        cat_cols <- sort(unique(cat_cols))
      }

      current <- isolate(input$outlier_label)
      if (is.null(current) || !nzchar(current) || !current %in% cat_cols) {
        current <- ""
      }

      with_help_tooltip(
        selectInput(
          ns("outlier_label"),
          label = "Label outliers by",
          choices = c("None" = "", stats::setNames(cat_cols, cat_cols)),
          selected = current
        ),
        "Choose a column to annotate the highlighted outliers."
      )
    })

    cached_plot_info <- reactiveVal(NULL)
    cache_ready <- reactiveVal(FALSE)

    invalidate_cache <- function() {
      cached_plot_info(NULL)
      cache_ready(FALSE)
      invisible(TRUE)
    }

    observeEvent(
      list(
        summary_info(),
        filtered_data(),
        input$show_points,
        input$show_outliers,
        input$outlier_label,
        custom_colors(),
        base_size()
      ),
      {
        invalidate_cache()
      },
      ignoreNULL = FALSE
    )

    observeEvent(input$resp_rows, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_rows"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    observeEvent(input$resp_cols, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_cols"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    compute_plot_info <- function() {
      info <- summary_info()

      validate(need(!is.null(info), "Summary not available."))

      processed <- resolve_input_value(info$processed_data)
      dat <- if (!is.null(processed)) processed else filtered_data()

      validate(need(!is.null(dat) && is.data.frame(dat) && nrow(dat) > 0, "No data available."))

      selected_vars <- resolve_input_value(info$selected_vars)
      group_var     <- resolve_input_value(info$group_var)

      out <- build_descriptive_numeric_boxplot(
        df = dat,
        selected_vars = selected_vars,
        group_var = group_var,
        show_points = isTRUE(input$show_points),
        show_outliers = isTRUE(input$show_outliers),
        outlier_label_var = validate_outlier_label(input$outlier_label),
        nrow_input = input$resp_rows,
        ncol_input = input$resp_cols,
        custom_colors = custom_colors(),
        base_size = base_size()
      )

      validate(need(!is.null(out), "No numeric variables available for plotting."))
      out
    }

    plot_info <- reactive({
      req(module_active())
      if (!isTRUE(cache_ready())) {
        cached_plot_info(compute_plot_info())
        cache_ready(TRUE)
      }
      cached_plot_info()
    })

    plot_size <- reactive({
      req(module_active())
      info <- plot_info()
      layout <- info$layout
      if (is.null(layout)) {
        list(w = plot_width(), h = plot_height())
      } else {
        list(
          w = plot_width()  * layout$ncol,
          h = plot_height() * layout$nrow
        )
      }
    })

    observeEvent(plot_info(), {
      info <- plot_info()
      if (is.null(info) || is.null(info$defaults)) return()

      rows <- info$defaults$rows
      cols <- info$defaults$cols
      if (is.null(rows) || is.null(cols)) return()

      sync_numeric_input(session, "resp_rows", input$resp_rows, rows)
      sync_numeric_input(session, "resp_cols", input$resp_cols, cols)
    }, ignoreNULL = FALSE)

    output$grid_warning <- renderUI({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning)) {
        div(class = "alert alert-warning", info$warning)
      } else {
        NULL
      }
    })

    output$download_plot <- downloadHandler(
      filename = function() paste0("numeric_boxplots_", Sys.Date(), ".png"),
      content  = function(file) {
        req(module_active())
        info <- plot_info()
        req(is.null(info$warning))
        req(info$plot)
        s <- plot_size()
        ggplot2::ggsave(
          filename = file,
          plot = info$plot,
          device = "png",
          dpi = 300,
          width  = s$w / 96,
          height = s$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )

    output$plot <- renderPlot({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning) || is.null(info$plot)) return(NULL)
      print(info$plot)
    },
    width = function() {
      req(module_active())
      plot_size()$w
    },
    height = function() {
      req(module_active())
      plot_size()$h
    },
    res = 96)
  })
}


build_descriptive_numeric_boxplot <- function(df,
                                              selected_vars = NULL,
                                              group_var = NULL,
                                              show_points = TRUE,
                                              show_outliers = FALSE,
                                              outlier_label_var = NULL,
                                              nrow_input = NULL,
                                              ncol_input = NULL,
                                              custom_colors = NULL,
                                              base_size = 13) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)

  num_vars <- names(df)[vapply(df, is.numeric, logical(1))]
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    num_vars <- intersect(num_vars, selected_vars)
  }
  if (length(num_vars) == 0) return(NULL)
  
  # ensure discrete x if grouped
  if (!is.null(group_var) && group_var %in% names(df)) {
    df[[group_var]] <- as.factor(df[[group_var]])
  } else {
    group_var <- NULL
  }
  
  plots <- lapply(num_vars, function(var) {
    # skip all-NA vars early
    vec <- df[[var]]
    if (all(is.na(vec))) return(NULL)
    
    if (!is.null(group_var)) {
      group_levels <- levels(df[[group_var]])
      palette <- resolve_palette_for_levels(group_levels, custom = custom_colors)
      p <- ggplot(df, aes(x = .data[[group_var]], y = .data[[var]], fill = .data[[group_var]])) +
        geom_boxplot(outlier.shape = NA, width = 0.6) +
        scale_fill_manual(values = palette) +
        theme_minimal(base_size = base_size) +
        labs(title = var, x = NULL, y = var) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
      added_color_scale <- FALSE
      if (isTRUE(show_points)) {
        p <- p +
          geom_jitter(aes(color = .data[[group_var]]), width = 0.2, alpha = 0.5, size = 1) +
          scale_color_manual(values = palette, guide = "none")
        added_color_scale <- TRUE
      }

      if (isTRUE(show_outliers)) {
        outliers <- prepare_boxplot_outliers(
          data = df,
          value_col = var,
          group_col = group_var,
          label_col = outlier_label_var
        )
        if (!is.null(outliers) && nrow(outliers) > 0) {
          p <- p + geom_point(
            data = outliers,
            aes(x = x, y = y, color = group),
            inherit.aes = FALSE,
            size = 2.5,
            show.legend = FALSE
          )
          if (!added_color_scale) {
            p <- p + scale_color_manual(values = palette, guide = "none")
            added_color_scale <- TRUE
          }
          label_data <- outliers[!is.na(outliers$label) & nzchar(outliers$label), , drop = FALSE]
          if (nrow(label_data) > 0) {
            p <- p + ggrepel::geom_text_repel(
              data = label_data,
              aes(x = x, y = y, label = label, color = group),
              inherit.aes = FALSE,
              size = 3,
              max.overlaps = Inf,
              min.segment.length = 0,
              box.padding = 0.3,
              point.padding = 0.2,
              show.legend = FALSE
            )
          }
        }
      }
    } else {
      # âœ… always provide an x aesthetic
      p <- ggplot(df, aes(x = factor(1), y = .data[[var]])) +
        geom_boxplot(fill = resolve_single_color(custom_colors), width = 0.3) +
        theme_minimal(base_size = base_size) +
        labs(title = var, x = NULL, y = var) +
        theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
      if (isTRUE(show_points)) {
        p <- p + geom_jitter(color = resolve_single_color(custom_colors), width = 0.05, alpha = 0.5, size = 1)
      }
      if (isTRUE(show_outliers)) {
        outliers <- prepare_boxplot_outliers(
          data = df,
          value_col = var,
          label_col = outlier_label_var
        )
        if (!is.null(outliers) && nrow(outliers) > 0) {
          single_color <- resolve_single_color(custom_colors)
          p <- p + geom_point(
            data = outliers,
            aes(x = x, y = y),
            inherit.aes = FALSE,
            color = single_color,
            size = 2.5,
            show.legend = FALSE
          )
          label_data <- outliers[!is.na(outliers$label) & nzchar(outliers$label), , drop = FALSE]
          if (nrow(label_data) > 0) {
            p <- p + ggrepel::geom_text_repel(
              data = label_data,
              aes(x = x, y = y, label = label),
              inherit.aes = FALSE,
              size = 3,
              color = single_color,
              max.overlaps = Inf,
              min.segment.length = 0,
              box.padding = 0.3,
              point.padding = 0.2,
              show.legend = FALSE
            )
          }
        }
      }
    }

    if (inherits(p, "gg")) p else NULL
  })
  
  # keep only valid ggplots
  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)
  
  n_panels <- length(plots)
  defaults <- list(
    rows = 1L,
    cols = max(1L, as.integer(n_panels))
  )

  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols,
    max_cols = max(100L, as.integer(defaults$cols))
  )

  layout <- adjust_grid_layout(n_panels, layout)

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)

  combined <- NULL
  if (isTRUE(validation$valid)) {
    combined <- patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol) +
      patchwork::plot_annotation(
        theme = theme(plot.title = element_text(size = 16, face = "bold"))
      )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}


validate_outlier_label <- function(label_input) {
  if (is.null(label_input) || !nzchar(label_input)) {
    return(NULL)
  }
  label_input
}


prepare_boxplot_outliers <- function(data,
                                     value_col,
                                     group_col = NULL,
                                     label_col = NULL) {
  if (is.null(data) || !is.data.frame(data) || !value_col %in% names(data)) {
    return(NULL)
  }

  clean_labels <- function(values) {
    if (is.null(values)) return(rep(NA_character_, length.out = 0))
    out <- as.character(values)
    out[is.na(out) | trimws(out) == ""] <- NA_character_
    out
  }

  if (!is.null(group_col) && group_col %in% names(data)) {
    grouped <- data
    grouped[[group_col]] <- droplevels(as.factor(grouped[[group_col]]))
    group_levels <- levels(grouped[[group_col]])

    out_list <- lapply(group_levels, function(lvl) {
      subset <- grouped[grouped[[group_col]] == lvl, , drop = FALSE]
      values <- subset[[value_col]]
      values <- values[!is.na(values)]
      if (length(values) == 0) return(NULL)
      stats <- stats::quantile(values, probs = c(0.25, 0.75), na.rm = TRUE, names = FALSE)
      if (anyNA(stats)) return(NULL)
      iqr <- stats[2] - stats[1]
      lower <- stats[1] - 1.5 * iqr
      upper <- stats[2] + 1.5 * iqr
      idx <- which(subset[[value_col]] < lower | subset[[value_col]] > upper)
      if (length(idx) == 0) return(NULL)

      labels <- if (!is.null(label_col) && label_col %in% names(subset)) {
        clean_labels(subset[[label_col]][idx])
      } else {
        rep(NA_character_, length(idx))
      }

      data.frame(
        x = factor(rep(lvl, length(idx)), levels = group_levels),
        y = subset[[value_col]][idx],
        group = factor(rep(lvl, length(idx)), levels = group_levels),
        label = labels,
        stringsAsFactors = FALSE
      )
    })

    out_list <- Filter(Negate(is.null), out_list)
    if (length(out_list) == 0) {
      return(NULL)
    }
    outliers <- do.call(rbind, out_list)
    rownames(outliers) <- NULL
    return(outliers)
  }

  values <- data[[value_col]]
  values <- values[!is.na(values)]
  if (length(values) == 0) return(NULL)
  stats <- stats::quantile(values, probs = c(0.25, 0.75), na.rm = TRUE, names = FALSE)
  if (anyNA(stats)) return(NULL)
  iqr <- stats[2] - stats[1]
  lower <- stats[1] - 1.5 * iqr
  upper <- stats[2] + 1.5 * iqr
  idx <- which(data[[value_col]] < lower | data[[value_col]] > upper)
  if (length(idx) == 0) return(NULL)

  labels <- if (!is.null(label_col) && label_col %in% names(data)) {
    clean_values <- clean_labels(data[[label_col]][idx])
    clean_values
  } else {
    rep(NA_character_, length(idx))
  }

  data.frame(
    x = factor(rep(1, length(idx))),
    y = data[[value_col]][idx],
    group = NA,
    label = labels,
    stringsAsFactors = FALSE
  )
}

# ===============================================================
# ðŸŸ¦ Descriptive Visualization â€” Numeric Histograms
# ===============================================================

visualize_numeric_histograms_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(ns("use_density"), "Show density instead of count", FALSE),
      "Switch between showing counts or densities for each histogram."
    ),
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("plot_width"),  "Subplot width (px)",  400, 200, 2000, 50),
        "Set the width of each histogram panel in pixels."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("plot_height"), "Subplot height (px)", 300, 200, 2000, 50),
        "Set the height of each histogram panel in pixels."
      ))
    ),
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("resp_rows"), "Grid rows",    value = NA, min = 1, max = 10, step = 1),
        "Choose how many rows of histograms to display when several charts are shown."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("resp_cols"), "Grid columns", value = NA, min = 1, max = 10, step = 1),
        "Choose how many columns of histograms to display when several charts are shown."
      ))
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 13,
        help_text = "Adjust the base font size used for histogram text elements."
      ))
    ),
    hr(),
    with_help_tooltip(
      downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
      "Save the histograms as an image file."
    )
  )
}


visualize_numeric_histograms_plot_ui <- function(id) {
  ns <- NS(id)
  div(
    class = "ta-plot-container",
    uiOutput(ns("grid_warning")),
    plotOutput(ns("plot"), width = "100%", height = "auto")
  )
}


visualize_numeric_histograms_server <- function(id, filtered_data, summary_info, is_active = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    resolve_input_value <- function(x) {
      if (is.null(x)) return(NULL)
      if (is.reactive(x)) x() else x
    }

    module_active <- reactive({
      if (is.null(is_active)) {
        TRUE
      } else {
        isTRUE(is_active())
      }
    })

    plot_width <- reactive({
      w <- input$plot_width
      if (is.null(w) || !is.numeric(w) || is.na(w)) 400 else w
    })

    plot_height <- reactive({
      h <- input$plot_height
      if (is.null(h) || !is.numeric(h) || is.na(h)) 300 else h
    })

    color_var_reactive <- reactive({
      info <- summary_info()
      if (is.null(info)) return(NULL)

      group_var <- resolve_input_value(info$group_var)
      if (is.null(group_var) || identical(group_var, "") || identical(group_var, "None")) {
        return(NULL)
      }

      dat <- filtered_data()
      if (is.null(dat) || !is.data.frame(dat) || !group_var %in% names(dat)) {
        return(NULL)
      }

      group_var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = filtered_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 13
    )

    cached_plot_info <- reactiveVal(NULL)
    cache_ready <- reactiveVal(FALSE)

    invalidate_cache <- function() {
      cached_plot_info(NULL)
      cache_ready(FALSE)
      invisible(TRUE)
    }

    observeEvent(
      list(
        summary_info(),
        filtered_data(),
        input$use_density,
        custom_colors(),
        base_size()
      ),
      {
        invalidate_cache()
      },
      ignoreNULL = FALSE
    )

    observeEvent(input$resp_rows, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_rows"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    observeEvent(input$resp_cols, {
      if (isTRUE(consume_pending_numeric_update(session, "resp_cols"))) {
        return()
      }
      invalidate_cache()
    }, ignoreNULL = FALSE)

    compute_plot_info <- function() {
      info <- summary_info()
      validate(need(!is.null(info), "Summary not available."))

      processed <- resolve_input_value(info$processed_data)
      dat <- if (!is.null(processed)) processed else filtered_data()
      validate(need(!is.null(dat) && is.data.frame(dat) && nrow(dat) > 0, "No data available."))

      selected_vars <- resolve_input_value(info$selected_vars)
      group_var     <- resolve_input_value(info$group_var)
      strata_levels <- resolve_input_value(info$strata_levels)

      out <- build_descriptive_numeric_histogram(
        df = dat,
        selected_vars = selected_vars,
        group_var = group_var,
        strata_levels = strata_levels,
        use_density = isTRUE(input$use_density),
        nrow_input = input$resp_rows,
        ncol_input = input$resp_cols,
        custom_colors = custom_colors(),
        base_size = base_size()
      )
      validate(need(!is.null(out), "No numeric variables available for plotting."))
      out
    }

    plot_info <- reactive({
      req(module_active())
      if (!isTRUE(cache_ready())) {
        cached_plot_info(compute_plot_info())
        cache_ready(TRUE)
      }
      cached_plot_info()
    })


    plot_size <- reactive({
      req(module_active())
      info <- plot_info()
      if (is.null(info$layout)) {
        list(w = plot_width(), h = plot_height())
      } else {
        list(
          w = plot_width()  * info$layout$ncol,
          h = plot_height() * info$layout$nrow
        )
      }
    })

    observeEvent(plot_info(), {
      info <- plot_info()
      if (is.null(info) || is.null(info$defaults)) return()

      rows <- info$defaults$rows
      cols <- info$defaults$cols
      if (is.null(rows) || is.null(cols)) return()

      sync_numeric_input(session, "resp_rows", input$resp_rows, rows)
      sync_numeric_input(session, "resp_cols", input$resp_cols, cols)
    }, ignoreNULL = FALSE)

    output$grid_warning <- renderUI({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning)) {
        div(class = "alert alert-warning", info$warning)
      } else {
        NULL
      }
    })

    output$download_plot <- downloadHandler(
      filename = function() paste0("numeric_histograms_", Sys.Date(), ".png"),
      content  = function(file) {
        req(module_active())
        info <- plot_info()
        req(is.null(info$warning))
        req(info$plot)
        s <- plot_size()
        ggplot2::ggsave(
          filename = file,
          plot = info$plot,
          device = "png",
          dpi = 300,
          width  = s$w / 96,
          height = s$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )

    output$plot <- renderPlot({
      req(module_active())
      info <- plot_info()
      if (!is.null(info$warning) || is.null(info$plot)) return(NULL)
      print(info$plot)
    },
    width = function() {
      req(module_active())
      plot_size()$w
    },
    height = function() {
      req(module_active())
      plot_size()$h
    },
    res = 96)
  })
}


build_descriptive_numeric_histogram <- function(df,
                                                selected_vars = NULL,
                                                group_var = NULL,
                                                strata_levels = NULL,
                                                use_density = FALSE,
                                                nrow_input = NULL,
                                                ncol_input = NULL,
                                                custom_colors = NULL,
                                                base_size = 13) {
  if (is.null(df) || !is.data.frame(df) || nrow(df) == 0) return(NULL)
  
  num_vars <- names(df)[vapply(df, is.numeric, logical(1))]
  if (!is.null(selected_vars) && length(selected_vars) > 0) {
    num_vars <- intersect(num_vars, selected_vars)
  }
  if (length(num_vars) == 0) return(NULL)
  
  if (!is.null(group_var) && group_var %in% names(df)) {
    df[[group_var]] <- as.character(df[[group_var]])
    df[[group_var]][is.na(df[[group_var]]) | trimws(df[[group_var]]) == ""] <- "Missing"
    
    if (!is.null(strata_levels) && length(strata_levels) > 0) {
      keep_levels <- unique(strata_levels)
      df <- df[df[[group_var]] %in% keep_levels, , drop = FALSE]
      if (nrow(df) == 0) return(NULL)
      df[[group_var]] <- factor(df[[group_var]], levels = keep_levels)
    } else {
      df[[group_var]] <- factor(df[[group_var]], levels = unique(df[[group_var]]))
    }
  } else {
    group_var <- NULL
  }
  
  plots <- lapply(num_vars, function(var) {
    cols <- c(var, group_var)
    cols <- cols[cols %in% names(df)]
    plot_data <- df[, cols, drop = FALSE]
    
    keep <- is.finite(plot_data[[var]])
    keep[is.na(keep)] <- FALSE
    plot_data <- plot_data[keep, , drop = FALSE]
    if (nrow(plot_data) == 0) return(NULL)
    
    if (!is.null(group_var)) {
      plot_data[[group_var]] <- droplevels(plot_data[[group_var]])
    }

    density_mode <- isTRUE(use_density) && length(unique(plot_data[[var]])) > 1
    
    base <- ggplot(plot_data, aes(x = .data[[var]]))
    y_label <- if (density_mode) "Density" else "Count"
    
    if (!is.null(group_var)) {
      group_levels <- levels(plot_data[[group_var]])
      palette <- resolve_palette_for_levels(group_levels, custom = custom_colors)
      if (density_mode) {
        p <- base +
          geom_density(aes(color = .data[[group_var]], fill = .data[[group_var]]), alpha = 0.3) +
          scale_color_manual(values = palette) +
          scale_fill_manual(values = palette) +
          labs(color = group_var, fill = group_var)
      } else {
        p <- base +
          geom_histogram(
            aes(fill = .data[[group_var]]),
            position = "identity",
            alpha = 0.5,
            bins = 30
          ) +
          scale_fill_manual(values = palette) +
          labs(fill = group_var)
      }
    } else {
      single_color <- resolve_single_color(custom_colors)
      if (density_mode) {
        p <- base + geom_density(fill = single_color, color = single_color, alpha = 0.35)
      } else {
        p <- base + geom_histogram(fill = single_color, color = single_color, bins = 30)
      }
    }
    
    p +
      theme_minimal(base_size = base_size) +
      labs(title = var, x = var, y = y_label)
  })
  
  plots <- Filter(Negate(is.null), plots)
  if (length(plots) == 0) return(NULL)
  
  n_panels <- length(plots)
  defaults <- compute_default_grid(n_panels)

  layout <- basic_grid_layout(
    rows = suppressWarnings(as.numeric(nrow_input)),
    cols = suppressWarnings(as.numeric(ncol_input)),
    default_rows = defaults$rows,
    default_cols = defaults$cols
  )

  layout <- adjust_grid_layout(n_panels, layout)

  validation <- validate_grid(n_panels, layout$nrow, layout$ncol)

  combined <- NULL
  if (isTRUE(validation$valid)) {
    combined <- patchwork::wrap_plots(plots, nrow = layout$nrow, ncol = layout$ncol) +
      patchwork::plot_annotation(
        theme = theme(plot.title = element_text(size = 16, face = "bold"))
      )
  }

  list(
    plot = combined,
    layout = list(nrow = layout$nrow, ncol = layout$ncol),
    panels = n_panels,
    warning = validation$message,
    defaults = defaults
  )
}
format_safe_error_message <- function(title, details = NULL) {
  if (is.null(title) || !nzchar(title)) {
    title <- "Error"
  }

  if (inherits(details, "condition")) {
    details <- conditionMessage(details)
  }

  if (is.null(details)) {
    details <- ""
  }

  if (is.list(details)) {
    details <- unlist(details, recursive = TRUE, use.names = FALSE)
  }

  details <- vapply(details, as.character, character(1), USE.NAMES = FALSE)
  details <- trimws(details)
  details <- details[nzchar(details)]

  if (length(details) == 0) {
    return(paste0(title, ":"))
  }

  paste0(title, ":\n", paste(details, collapse = "\n"))
}
# ===============================================================
# ðŸ§® Linear Model (LM) â€” fixed effects only
# ===============================================================

lm_ui <- function(id) regression_ui(id, "lm", allow_multi_response = TRUE)

lm_server <- function(id, data) regression_server(id, data, "lm", allow_multi_response = TRUE)
# ===============================================================
# ðŸ§¬ Linear Mixed Model (LMM) â€” single random intercept
# ===============================================================

lmm_ui <- function(id) regression_ui(id, "lmm", allow_multi_response = TRUE)

lmm_server <- function(id, data) regression_server(id, data, "lmm", allow_multi_response = TRUE)
# ===============================================================
# ðŸ§© Helpers for LMM
# ===============================================================

compute_icc <- function(model) {
  if (!inherits(model, "merMod")) return(NA_real_)
  
  vc <- as.data.frame(VarCorr(model))
  if (nrow(vc) < 2) return(NA_real_)
  
  # residual variance is always the last row
  var_residual <- vc$vcov[nrow(vc)]
  
  # compute ICC for each random effect
  icc_list <- lapply(seq_len(nrow(vc) - 1), function(i) {
    var_random <- vc$vcov[i]
    icc_value <- var_random / (var_random + var_residual)
    data.frame(
      Group = vc$grp[i],
      ICC   = round(icc_value, 3),
      stringsAsFactors = FALSE
    )
  })
  
  icc_df <- do.call(rbind, icc_list)
  rownames(icc_df) <- NULL
  icc_df
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Analysis Coordinator
# ===============================================================

analysis_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 3 â€” Analyze results"),
      p("Select an analysis type to explore your data, then inspect the summaries on the right."),
      hr(),
      
      # --- CSS: expand dropdown height for better visibility ---
      tags$style(HTML(sprintf("
        #%s + .selectize-control .selectize-dropdown,
        #%s + .selectize-control .selectize-dropdown .selectize-dropdown-content {
          max-height: none !important;
        }
      ", ns("analysis_type"), ns("analysis_type")))),
      
      # --- Analysis type selector ---
      with_help_tooltip(
        selectInput(
          ns("analysis_type"),
          "Select analysis type",
          choices = list(
            " " = "",
            "Descriptive" = c("Descriptive Statistics" = "Descriptive Statistics"),
            "Univariate" = c(
              "One-way ANOVA" = "One-way ANOVA",
              "Two-way ANOVA" = "Two-way ANOVA",
              "Linear Model (LM)" = "Linear Model (LM)",
              "Linear Mixed Model (LMM)" = "Linear Mixed Model (LMM)"
            ),
            "Multivariate" = c(
              "Pairwise Correlation" = "Pairwise Correlation",
              "Principal Component Analysis (PCA)" = "PCA"
            )
          ),
          selected = ""
        ),
        "Choose the statistical method you want to run on the filtered data."
      ),
      uiOutput(ns("config_panel"))
    ),
    
    mainPanel(
      width = 8,
      h4("Analysis results"),
      uiOutput(ns("results_panel"))
    )
  )
}


analysis_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(filtered_data())
    
    # ---- Mapping of available modules ----
    modules <- list(
      "Descriptive Statistics" = list(id = "desc",  ui = descriptive_ui, server = descriptive_server, type = "desc"),
      "One-way ANOVA"          = list(id = "anova1", ui = one_way_anova_ui, server = one_way_anova_server, type = "anova1"),
      "Two-way ANOVA"          = list(id = "anova2", ui = two_way_anova_ui, server = two_way_anova_server, type = "anova2"),
      "Linear Model (LM)"      = list(id = "lm",     ui = lm_ui, server = lm_server, type = "lm"),
      "Linear Mixed Model (LMM)" = list(id = "lmm",  ui = lmm_ui, server = lmm_server, type = "lmm"),
      "Pairwise Correlation"   = list(id = "pairs",  ui = ggpairs_ui, server = ggpairs_server, type = "pairs"),
      "PCA"                    = list(id = "pca",    ui = pca_ui, server = pca_server, type = "pca")
    )
    
    # ---- Cache for lazily created servers ----
    server_cache <- reactiveValues()
    
    # ---- Current module getter ----
    current_mod <- reactive({
      type <- input$analysis_type
      req(type)
      modules[[type]]
    })
    
    current_ui <- reactive({
      mod <- current_mod()
      req(mod)
      mod$ui(ns(mod$id))
    })
    
    # ---- Lazy server initialization ----
    normalize_analysis_type <- function(mod_type) {
      lookup <- c(
        desc = "DESCRIPTIVE",
        anova1 = "ANOVA",
        anova2 = "ANOVA",
        lm = "LM",
        lmm = "LMM",
        pairs = "CORR",
        pca = "PCA"
      )
      lookup[[mod_type]] %||% toupper(mod_type)
    }
    

    ensure_module_server <- function(mod) {
      key <- mod$id
      if (!is.null(server_cache[[key]])) return(server_cache[[key]])
      
      result <- tryCatch(mod$server(mod$id, df), error = function(e) {
        warning(sprintf("Module '%s' failed to initialize: %s", key, conditionMessage(e)))
        NULL
      })
      
      default_type <- normalize_analysis_type(mod$type)
      
      # --- Standardize all outputs to a reactive returning a list ---
      standardized <- reactive({
        val <- if (is.reactive(result)) result() else result
        req(val)
        
        val$analysis_type <- val$analysis_type %||% default_type
        val$type <- val$type %||% mod$type
        val$data_used <- val$data_used %||% NULL
        val$summary <- val$summary %||% NULL
        val$posthoc <- val$posthoc %||% NULL
        val$effects <- val$effects %||% NULL
        val$stats <- val$stats %||% NULL
        val$metadata <- val$metadata %||% list()
        val
      })
      
      server_cache[[key]] <- standardized
      standardized
    }
    
    
    # ---- Render active submodule UI ----
    output$config_panel <- renderUI({
      ui <- current_ui()
      req(ui)
      ui$config
    })
    
    output$results_panel <- renderUI({
      ui <- current_ui()
      req(ui)
      ui$results
    })
    
    # ---- Connect the current selected module's server ----
    current_server <- reactive({
      mod <- current_mod()
      req(mod)
      ensure_module_server(mod)
    })
    
    # ---- Unified model output ----
    model_out <- reactive({
      srv <- current_server()
      req(srv)
      srv()
    })
    
    # Return the active model output as a reactive
    model_out
  })
}
# ===============================================================
# ðŸŽ¨ Module for colors customization
# ===============================================================

add_color_customization_ui <- function(ns, multi_group = TRUE) {
  uiOutput(ns("color_custom_ui"))
}

# ---- SERVER ----
add_color_customization_server <- function(ns, input, output, data, color_var_reactive, multi_group = TRUE) {
  default_color <- "steelblue"
  
  # ---- Dynamic UI ----
  output$color_custom_ui <- renderUI({
    req(data())
    
    color_var <- color_var_reactive() %||% ""
    
    # Single color UI shown when multi-group off or no color_var available
    if (!isTRUE(multi_group) || color_var %in% c("", "None")) {
      tagList(
        h5("Color"),
        with_help_tooltip(
          color_dropdown_input(ns, "single_color", basic_color_palette, ncol = 4),
          "Choose the colour used for the entire plot."
        )
      )
    } else {
      render_color_inputs(ns, data, color_var)
    }
  })
  
  # ---- Reactive color mapping ----
  reactive({
    # --- Single-color mode (no grouping variable or disabled) ---
    if (!isTRUE(multi_group)) {
      return(input$single_color %||% default_color)
    }
    
    color_var <- color_var_reactive() %||% ""
    if (color_var %in% c("", "None")) {
      return(input$single_color %||% default_color)
    }
    
    dataset <- data()
    req(dataset)
    
    if (!color_var %in% names(dataset)) {
      return(input$single_color %||% default_color)
    }
    
    lvls <- levels(as.factor(dataset[[color_var]]))
    base_palette <- rep(basic_color_palette, length.out = length(lvls))
    
    cols <- vapply(seq_along(lvls), function(i) {
      input[[paste0("col_", color_var, "_", i)]] %||% base_palette[i]
    }, character(1))
    
    names(cols) <- lvls
    cols
  })
}
# ===============================================================
# ðŸŽ¨ UI helper to assign colors per level of a factor
# ===============================================================

render_color_inputs <- function(ns, data, color_var) {
  if (is.null(color_var) || color_var == "None") return(NULL)
  if (!color_var %in% names(data())) return(NULL)

  values <- data()[[color_var]]
  lvls <- if (is.factor(values)) levels(values) else unique(as.character(values))
  lvls <- lvls[!is.na(lvls)]
  default_palette <- rep(basic_color_palette, length.out = length(lvls))

  tagList(
    h5("Colors"),
    lapply(seq_along(lvls), function(i) {
      selected <- default_palette[i]
      tags$div(
        style = "margin-bottom: 8px;",
        tags$label(lvls[i], style = "display:block; margin-bottom: 4px;"),
        with_help_tooltip(
          color_dropdown_input(
            ns,
            id = paste0("col_", color_var, "_", i),
            palette = basic_color_palette,
            ncol = 4,
            selected = selected
          ),
          sprintf("Pick the colour that will represent %s in the plot.", lvls[i])
        )
      )
    })
  )
}

resolve_single_color <- function(custom = NULL) {
  if (!is.null(custom) && length(custom) > 0) {
    candidate <- unname(custom[[1]])
    if (!is.null(candidate) && nzchar(candidate)) {
      return(candidate)
    }
  }
  basic_color_palette[1]
}

resolve_palette_for_levels <- function(levels, custom = NULL) {
  if (is.null(levels) || length(levels) == 0) {
    return(resolve_single_color())
  }

  unique_levels <- unique(as.character(levels))
  palette_size <- length(basic_color_palette)
  n_levels <- length(unique_levels)

  if (!is.null(custom) && length(custom) > 0) {
    if (!is.null(names(custom))) {
      ordered <- custom[unique_levels]
      if (all(!is.na(ordered))) {
        return(ordered)
      }
    } else if (length(custom) >= n_levels) {
      return(stats::setNames(custom[seq_len(n_levels)], unique_levels))
    }
  }

  if (n_levels <= palette_size) {
    palette <- basic_color_palette[seq_len(n_levels)]
  } else {
    repeats <- ceiling(n_levels / palette_size)
    palette <- rep(basic_color_palette, repeats)[seq_len(n_levels)]
  }

  stats::setNames(palette, unique_levels)
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Filter Module (Refactored Reactive Version)
# ===============================================================

filter_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 2 â€” Filter records"),
      p("Select the columns to focus on and adjust the filters to refine the dataset for analysis."),
      hr(),
      uiOutput(ns("column_selector")),
      uiOutput(ns("filter_widgets"))
    ),
    mainPanel(
      width = 8,
      h4("Filtered data preview"),
      DTOutput(ns("filtered_preview"))
    )
  )
}

filter_server <- function(id, uploaded_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(uploaded_data())
    
    # --- 1. Column selector ---
    output$column_selector <- renderUI({
      req(df())
      with_help_tooltip(
        selectInput(
          ns("columns"),
          "Select columns to filter",
          choices = names(df()),
          multiple = TRUE
        ),
        "Choose which variables you want to filter before running analyses."
      )
    })
    
    # --- 2. Dynamic filter widgets ---
    output$filter_widgets <- renderUI({
      req(df())
      cols <- input$columns
      req(cols)
      
      make_numeric_widget <- function(col, x) {
        rng <- suppressWarnings(range(x, na.rm = TRUE))
        if (any(!is.finite(rng))) rng <- c(0, 0)
        step_val <- ifelse(diff(rng) == 0 || any(!is.finite(diff(rng))), 1, diff(rng) / 100)
        fluidRow(
          column(
            6,
            with_help_tooltip(
              numericInput(
                ns(paste0("min_", col)), paste(col, "(min)"),
                value = rng[1], min = rng[1], max = rng[2], step = step_val
              ),
              sprintf("Enter the smallest value to keep for %s.", col)
            )
          ),
          column(
            6,
            with_help_tooltip(
              numericInput(
                ns(paste0("max_", col)), paste(col, "(max)"),
                value = rng[2], min = rng[1], max = rng[2], step = step_val
              ),
              sprintf("Enter the largest value to keep for %s.", col)
            )
          )
        )
      }
      
      make_logical_widget <- function(col) {
        with_help_tooltip(
          checkboxGroupInput(
            ns(paste0("filter_", col)), label = col,
            choices = c(TRUE, FALSE), selected = c(TRUE, FALSE), inline = TRUE
          ),
          sprintf("Tick the logical values you want to keep for %s.", col)
        )
      }
      
      make_factor_widget <- function(col, x) {
        choices <- sort(unique(as.character(x)))
        with_help_tooltip(
          selectInput(
            ns(paste0("filter_", col)), label = col,
            choices = choices, multiple = TRUE, selected = choices
          ),
          sprintf("Choose which categories should remain for %s.", col)
        )
      }
      
      tagList(lapply(cols, function(col) {
        x <- df()[[col]]
        if (is.numeric(x)) make_numeric_widget(col, x)
        else if (is.logical(x)) make_logical_widget(col)
        else make_factor_widget(col, x)
      }))
    })
    
    # --- 3. Reactive filtering ---
    filtered_df <- reactive({
      req(df())
      data <- df()
      cols <- input$columns
      
      if (is.null(cols) || !length(cols)) return(data)
      
      for (col in cols) {
        x <- data[[col]]

        # Numeric columns
        if (is.numeric(x)) {
          min_val <- input[[paste0("min_", col)]] %||% -Inf
          max_val <- input[[paste0("max_", col)]] %||% Inf
          if (all(is.na(x))) {
            next
          }
          keep <- is.na(x) | (x >= min_val & x <= max_val)
          data <- data[keep, , drop = FALSE]
        }
        # Logical / Factor / Character
        else {
          sel <- input[[paste0("filter_", col)]] %||% character(0)
          if (!length(sel)) {
            data <- data[0, , drop = FALSE]
            break
          }
          keep <- is.na(x) | (as.character(x) %in% sel)
          data <- data[keep, , drop = FALSE]
        }
      }
      
      data
    })
    
    # --- 4. Preview table ---
    output$filtered_preview <- renderDT({
      datatable(filtered_df(), options = list(scrollX = TRUE, pageLength = 5))
    })
    
    # --- 5. Return filtered data downstream ---
    filtered_df
  })
}
# ===============================================================
# ðŸ  Table Analyzer â€” Home Module
# ===============================================================

home_ui <- function(id) {
  ns <- NS(id)

  fluidPage(
    div(
      class = "home-wrapper px-3",
      div(
        class = "hero text-center mx-auto",
        h1("Welcome to Table Analyzer"),
        p(
          class = "lead text-muted",
          "Turn your tabular data into publication-ready tables and plots."
        ),
        br(),
        div(
          class = "home-steps",
          fluidRow(
            class = "g-4 justify-content-center",
            column(
              width = 3,
              div(
                icon("upload", class = "fa-2x text-primary mb-2"),
                h5("1. Upload"),
                p("Bring in spreadsheets with ease.")
              )
            ),
            column(
              width = 3,
              div(
                icon("filter", class = "fa-2x text-primary mb-2"),
                h5("2. Filter"),
                p("Refine rows and columns to spotlight what's important.")
              )
            ),
            column(
              width = 3,
              div(
                icon("chart-line", class = "fa-2x text-primary mb-2"),
                h5("3. Analyze"),
                p("Run summaries and models tailored to your dataset.")
              )
            ),
            column(
              width = 3,
              div(
                icon("chart-area", class = "fa-2x text-primary mb-2"),
                h5("4. Visualize"),
                p("Create polished plots to communicate key findings.")
              )
            )
          )
        ),
        br(),
        tags$hr(class = "my-4"),
        p(
          em("Developed by Nicola Palmieri"),
          class = "text-muted small"
        )
      )
    )
  )
}


home_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    # Placeholder for future home page interactivity
  })
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” Upload Module (Stable wide-format version)
# ===============================================================

upload_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 1 â€” Upload data"),
      p("Choose whether to load the example dataset or upload your own Excel file."),
      hr(),
      with_help_tooltip(
        radioButtons(
          ns("data_source"),
          label = "Data source",
          choices = c(
            "Example dataset" = "example",
            "Upload (long format)" = "long",
            "Upload (wide format)" = "wide"
          ),
          selected = "example"
        ),
        "Decide whether to explore the built-in example data or load your own table."
      ),
      uiOutput(ns("layout_example")),
      with_help_tooltip(
        fileInput(
          ns("file"),
          "Upload Excel file (.xlsx / .xls / .xlsm)",
          accept = c(".xlsx", ".xls", ".xlsm")
        ),
        "Provide the Excel workbook that stores your study measurements."
      ),
      uiOutput(ns("sheet_selector")),
      uiOutput(ns("type_selectors"))
    ),
    mainPanel(
      width = 8,
      h4("Data preview"),
      verbatimTextOutput(ns("validation_msg")),
      DTOutput(ns("preview"))
    )
  )
}


upload_server <- function(id) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactiveVal(NULL)
    editable_cols <- reactiveVal(NULL)
    
    # -----------------------------------------------------------
    # 1ï¸âƒ£ Handle source selection
    # -----------------------------------------------------------
    observeEvent(input$data_source, {
      df(NULL)
      output$type_selectors <- renderUI(NULL)
      output$sheet_selector <- renderUI(NULL)
      output$preview <- renderDT(data.frame())
      
      if (input$data_source == "example") {
        path <- "data/toy_animal_trial_data_long.xlsx"
        validate(need(file.exists(path), "âš ï¸ Example dataset not found in data folder."))
        data <- readxl::read_excel(path)
        processed <- safe_preprocess_uploaded_table(data)
        if (!is.null(processed$error)) {
          output$validation_msg <- renderText(
            format_safe_error_message("Error preparing example dataset", processed$error)
          )
          return()
        }
        data <- processed$result
        df(data)
        output$validation_msg <- renderText("ðŸ“‚ Loaded built-in example dataset (long format).")
        output$preview <- renderDT(data, options = list(scrollX = TRUE, pageLength = 5))
        create_type_selectors(data)
      } else {
        output$validation_msg <- renderText("Please upload an Excel file.")
      }
    }, ignoreInit = FALSE)
    
    # -----------------------------------------------------------
    # 2ï¸âƒ£ Example layout preview
    # -----------------------------------------------------------
    output$layout_example <- renderUI({
      req(input$data_source %in% c("long", "wide"))
      long_path <- "data/toy_animal_trial_data_long.xlsx"
      wide_path <- "data/toy_animal_trial_data_wide.xlsx"
      validate(need(file.exists(long_path) && file.exists(wide_path),
                    "âŒ Example layout files not found in /data folder."))
      
      if (input$data_source == "long") {
        toy <- readxl::read_excel(long_path, n_max = 5)
        caption <- "Long format â€” one row per measurement."
      } else {
        toy <- readxl::read_excel(wide_path, n_max = 5)
        bad <- grepl("^\\.\\.\\.[0-9]+$", names(toy))
        names(toy)[bad] <- ""
        caption <- "Wide format â€” two header rows (top: response, bottom: replicate)."
      }
      
      DT::datatable(
        toy,
        caption = htmltools::tags$caption(htmltools::tags$b(caption)),
        options = list(dom = "t", scrollX = TRUE),
        rownames = FALSE,
        class = "compact stripe"
      )
    })
    
    # -----------------------------------------------------------
    # 3ï¸âƒ£ File upload â†’ detect sheets
    # -----------------------------------------------------------
    observeEvent(input$file, {
      req(input$data_source != "example")
      ext <- tolower(tools::file_ext(input$file$name))
      validate(need(ext %in% c("xlsx", "xls", "xlsm"),
                    "âŒ Invalid file type. Please upload .xlsx/.xls/.xlsm."))
      
      sheets <- tryCatch(readxl::excel_sheets(input$file$datapath),
                         error = function(e) NULL)
      validate(need(!is.null(sheets), "âŒ No readable sheets found in workbook."))
      
      output$validation_msg <- renderText(paste("âœ… File loaded:", input$file$name))
      output$sheet_selector <- renderUI(
        with_help_tooltip(
          selectInput(ns("sheet"), "Select sheet", choices = sheets),
          "Pick the worksheet inside your Excel file that contains the data."
        )
      )
    }, ignoreInit = TRUE)
    
    # -----------------------------------------------------------
    # 4ï¸âƒ£ Load selected sheet (handles both long & wide)
    # -----------------------------------------------------------
    observeEvent(list(input$sheet, input$data_source), {
      req(input$file, input$sheet, input$data_source != "example")
      path <- input$file$datapath
      data <- NULL
      
      success_message <- NULL

      if (input$data_source == "wide") {
        # âš™ï¸ Wide format conversion with error handling
        safe_result <- safe_convert_wide_to_long(
          path,
          sheet = input$sheet,
          replicate_col = "Replicate"
        )

        if (!is.null(safe_result$error)) {
          output$validation_msg <- renderText(
            format_safe_error_message("Error converting wide format", safe_result$error)
          )
          return()
        }

        data <- safe_result$result
        success_message <- "âœ… Wide format reshaped successfully."
      } else {
        # ðŸ§¾ Simple long format load
        data <- tryCatch(
          readxl::read_excel(path, sheet = input$sheet),
          error = function(e) {
            output$validation_msg <- renderText(
              paste("âŒ Error loading sheet:", conditionMessage(e))
            )
            NULL
          }
        )
        if (is.null(data)) return()
        success_message <- "âœ… Long format loaded successfully."
      }

      # âœ… Shared postprocessing and preview
      processed <- safe_preprocess_uploaded_table(data)
      if (!is.null(processed$error)) {
        output$validation_msg <- renderText(
          format_safe_error_message("Error preparing data", processed$error)
        )
        return()
      }

      data <- processed$result
      df(data)
      output$preview <- renderDT(data, options = list(scrollX = TRUE, pageLength = 5))
      create_type_selectors(data)
      if (!is.null(success_message)) {
        output$validation_msg <- renderText(success_message)
      }
    })
    
    # -----------------------------------------------------------
    # 5ï¸âƒ£ Create type selectors
    # -----------------------------------------------------------
    create_type_selectors <- function(data) {
      req(data)
      num_vars <- names(data)[sapply(data, is.numeric)]
      few_level_nums <- num_vars[sapply(data[num_vars], function(x)
        length(unique(na.omit(x))) <= 10)]
      editable_cols(few_level_nums)
      
      if (length(few_level_nums) == 0) {
        output$type_selectors <- renderUI(NULL)
        return()
      }
      
      output$type_selectors <- renderUI({
        tagList(
          h5("Ambiguous type columns"),
          lapply(few_level_nums, function(col) {
            with_help_tooltip(
              selectInput(
                ns(paste0("type_", col)),
                label = col,
                choices = c("Numeric", "Categorical"),
                selected = "Numeric",
                width = "100%"
              ),
              "Tell the app whether this column should be treated as numbers or as groups."
            )
          })
        )
      })
    }
    
    # -----------------------------------------------------------
    # 6ï¸âƒ£ Apply user type edits reactively
    # -----------------------------------------------------------
    observe({
      req(df(), editable_cols())
      data <- df()
      for (col in editable_cols()) {
        sel <- input[[paste0("type_", col)]] %||% "Numeric"
        if (sel == "Categorical") {
          data[[col]] <- factor(as.character(data[[col]]))
        } else {
          data[[col]] <- suppressWarnings(as.numeric(as.character(data[[col]])))
        }
      }
      df(data)
    })
    
    # -----------------------------------------------------------
    # âœ… Return reactive data
    # -----------------------------------------------------------
    df
  })
}
# Clean names + convert characters to ordered factors
preprocess_uploaded_table <- function(df) {
  df <- janitor::clean_names(df)
  df <- df |> mutate(across(where(is.character), auto_factor_order))
  df
}

# Convert character to factor with numeric-aware order
auto_factor_order <- function(x) {
  if (!is.character(x)) return(x)
  nums <- suppressWarnings(as.numeric(gsub("\\D", "", x)))
  if (all(is.na(nums))) {
    factor(x, levels = sort(unique(x)))
  } else {
    x <- factor(x, levels = unique(x[order(nums, na.last = TRUE)]))
    x
  }
}


convert_wide_to_long <- function(path, sheet = 1, replicate_col = "Replicate") {
  # ---- Read first two rows to capture merged header structure ----
  headers <- readxl::read_excel(path, sheet = sheet, n_max = 2, col_names = FALSE)
  header1 <- as.character(unlist(headers[1, , drop = TRUE]))
  header2 <- as.character(unlist(headers[2, , drop = TRUE]))
  
  # ---- Fill blanks forward in first header ----
  header1[header1 == ""] <- NA
  header1 <- zoo::na.locf(header1, na.rm = FALSE)
  header2[is.na(header2) | header2 == ""] <- ""
  
  # ---- Combine headers safely ----
  clean_names <- ifelse(header2 == "", header1, paste0(header1, "_", header2))
  clean_names <- make.unique(clean_names, sep = "_")
  
  # ---- Detect number of fixed columns ----
  first_empty <- which(is.na(headers[1, ]) | headers[1, ] == "")[1]
  if (is.na(first_empty)) {
    n_fixed <- 0
  } else {
    n_fixed <- max(0, first_empty - 2)
  }
  fixed_cols <- clean_names[seq_len(n_fixed)]
  measure_cols <- setdiff(clean_names, fixed_cols)
  
  # ---- Read data with computed names ----
  data <- readxl::read_excel(path, sheet = sheet, skip = 2, col_names = clean_names)
  
  # ---- Reshape from wide to long then back to tidy ----
  data_long <- data |>
    pivot_longer(
      cols = tidyselect::all_of(measure_cols),
      names_to = c("Variable", replicate_col),
      names_pattern = "^(.*)_([^_]*)$",
      values_to = "Value"
    )

  # ---- Detect duplicate measurements before widening ----
  id_cols <- c(fixed_cols, replicate_col, "Variable")
  duplicates <- data_long |>
    dplyr::group_by(dplyr::across(dplyr::all_of(id_cols))) |>
    dplyr::summarise(.n = dplyr::n(), .groups = "drop") |>
    dplyr::filter(.n > 1)

  if (nrow(duplicates) > 0) {
    example <- duplicates[1, , drop = FALSE]
    var_label <- example$Variable
    if (is.factor(var_label)) {
      var_label <- as.character(var_label)
    }
    if (length(var_label) == 0 || is.na(var_label) || identical(var_label, "")) {
      var_label <- "<unknown>"
    }

    replicate_label <- example[[replicate_col]]
    if (is.factor(replicate_label)) {
      replicate_label <- as.character(replicate_label)
    }
    if (length(replicate_label) == 0 || is.na(replicate_label) || identical(replicate_label, "")) {
      replicate_label <- "<blank>"
    }

    stop(
      sprintf(
        "Duplicate measurements detected for variable '%s' and replicate '%s'. Ensure header labels are unique before uploading.",
        var_label,
        replicate_label
      ),
      call. = FALSE
    )
  }

  data_long |>
    pivot_wider(names_from = "Variable", values_from = "Value") |>
    as_tibble()
}

safe_convert_wide_to_long <- purrr::safely(convert_wide_to_long)

safe_preprocess_uploaded_table <- purrr::safely(preprocess_uploaded_table)
# ===============================================================
# ðŸ§© Visualization Coordinator (Lazy + Reactive)
# ===============================================================

visualize_ui <- function(id) {
  ns <- NS(id)
  uiOutput(ns("dynamic_ui"))
}

visualize_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    # -----------------------------------------------------------
    # 1ï¸âƒ£ Reactive model info
    # -----------------------------------------------------------
    model_info_or_null <- reactive({
      tryCatch(
        model_fit(),
        shiny.silent.stop = function(e) NULL
      )
    })

    model_info <- reactive({
      info <- model_info_or_null()
      req(info)
      info
    })
    
    # -----------------------------------------------------------
    # 2ï¸âƒ£ Detect analysis type (robust default)
    # -----------------------------------------------------------
    analysis_type <- reactive({
      info <- model_info()
      type <- info$type %||% "oneway_anova"
      tolower(type)
    })
    
    # -----------------------------------------------------------
    # 3ï¸âƒ£ Visualization cache (like analysis_server)
    # -----------------------------------------------------------
    vis_cache <- reactiveValues()
    
    ensure_vis_server <- function(key, create_fn) {
      if (!is.null(vis_cache[[key]])) {
        return(vis_cache[[key]])
      }
      vis_cache[[key]] <- create_fn()
      vis_cache[[key]]
    }
    
    # -----------------------------------------------------------
    # 4ï¸âƒ£ Dynamic UI loading (lazy initialization)
    # -----------------------------------------------------------
    output$dynamic_ui <- renderUI({
      info <- model_info_or_null()

      if (is.null(info)) {
        return(
          div(
            class = "empty-state card bg-light border-0 shadow-sm text-center my-5",
            div(
              class = "card-body py-5 px-4",
              div(
                class = "empty-state-icon text-primary mb-3",
                HTML("&#128221;")
              ),
              h4(class = "mb-2", "No analysis selected yet"),
              p(
                class = "text-muted mb-0",
                "Run an analysis in the Analyze tab to unlock tailored visualizations for your results."
              )
            )
          )
        )
      }

      type <- analysis_type()
      switch(
        type,
        "oneway_anova"   = visualize_oneway_ui(ns("oneway")),
        "twoway_anova"   = visualize_twoway_ui(ns("twoway")),
        "pairs"          = visualize_ggpairs_ui(ns("ggpairs")),
        "pca"            = visualize_pca_ui(ns("pca"), filtered_data()),
        "descriptive"    = visualize_descriptive_ui(ns("descriptive")),
        div(
          class = "empty-state card bg-light border-0 shadow-sm text-center my-5",
          div(
            class = "card-body py-5 px-4",
            div(
              class = "empty-state-icon text-primary mb-3",
              HTML("&#128065;")
            ),
            h4(class = "mb-2", "Visualization coming soon"),
            p(
              class = "text-muted mb-0",
              "We're still crafting charts for this analysis type. In the meantime, explore the other visualizations available!"
            )
          )
        )
      )
    })
    
    # -----------------------------------------------------------
    # 5ï¸âƒ£ Attach or reuse visualization servers lazily
    # -----------------------------------------------------------
    observeEvent(analysis_type(), {
      type <- analysis_type()
      
      if (type == "oneway_anova") {
        ensure_vis_server("oneway", function() {
          visualize_oneway_server("oneway", filtered_data, model_info)
        })
      } else if (type == "twoway_anova") {
        ensure_vis_server("twoway", function() {
          visualize_twoway_server("twoway", filtered_data, model_info)
        })
      } else if (type == "pairs") {
        ensure_vis_server("ggpairs", function() {
          visualize_ggpairs_server("ggpairs", filtered_data, model_info)
        })
      } else if (type == "pca") {
        ensure_vis_server("pca", function() {
          visualize_pca_server("pca", filtered_data, model_info)
        })
      } else if (type == "descriptive") {
        ensure_vis_server("descriptive", function() {
          visualize_descriptive_server("descriptive", filtered_data, model_info)
        })
      }
    }, ignoreInit = FALSE)
    
  })
}
# ===============================================================
# ðŸ§± Basic grid layout helpers
# ===============================================================

compute_default_grid <- function(n) {
  n <- max(1L, as.integer(n))
  rows <- ceiling(sqrt(n))
  cols <- ceiling(n / rows)
  list(rows = rows, cols = cols)
}

validate_grid <- function(n_items, rows, cols) {
  n_items <- max(1L, as.integer(n_items))
  rows <- max(1L, as.integer(rows))
  cols <- max(1L, as.integer(cols))

  too_small <- rows * cols < n_items
  empty_row <- n_items <= (rows - 1L) * cols
  empty_col <- n_items <= rows * (cols - 1L)
  too_large <- (!too_small) && (empty_row || empty_col)

  if (too_small) {
    return(list(
      valid = FALSE,
      message = sprintf("âš ï¸ Grid %dx%d too small for %d subplots.", rows, cols, n_items)
    ))
  }

  if (too_large) {
    return(list(
      valid = FALSE,
      message = sprintf("âš ï¸ Grid %dx%d too large for %d subplots.", rows, cols, n_items)
    ))
  }

  list(valid = TRUE, message = NULL)
}

basic_grid_value <- function(value,
                             default = 1L,
                             min_value = 1L,
                             max_value = 10L) {
  if (is.null(value) || length(value) == 0) {
    return(as.integer(default))
  }

  raw <- suppressWarnings(as.integer(value[1]))
  if (is.na(raw)) {
    return(as.integer(default))
  }

  adjusted <- max(as.integer(min_value), raw)
  if (!is.null(max_value)) {
    adjusted <- min(as.integer(max_value), adjusted)
  }

  as.integer(adjusted)
}

basic_grid_layout <- function(rows = NULL,
                              cols = NULL,
                              default_rows = 1L,
                              default_cols = 1L,
                              min_rows = 1L,
                              min_cols = 1L,
                              max_rows = 10L,
                              max_cols = 10L) {
  list(
    nrow = basic_grid_value(
      value = rows,
      default = default_rows,
      min_value = min_rows,
      max_value = max_rows
    ),
    ncol = basic_grid_value(
      value = cols,
      default = default_cols,
      min_value = min_cols,
      max_value = max_cols
    )
  )
}

adjust_grid_layout <- function(n_items, layout) {
  if (is.null(layout) || length(layout) == 0) {
    return(list(nrow = 1L, ncol = 1L))
  }

  if (is.null(n_items) || length(n_items) == 0 || is.na(n_items)) {
    n_items <- 1L
  }
  n_items <- max(1L, as.integer(n_items))

  rows <- layout$nrow
  cols <- layout$ncol

  if (is.null(rows) || length(rows) == 0 || is.na(rows)) {
    rows <- 1L
  }
  if (is.null(cols) || length(cols) == 0 || is.na(cols)) {
    cols <- 1L
  }

  rows <- max(1L, as.integer(rows))
  cols <- max(1L, as.integer(cols))

  if (rows * cols <= n_items) {
    return(list(nrow = rows, ncol = cols))
  }

  repeat {
    adjusted <- FALSE

    if (rows > 1L && (rows - 1L) * cols >= n_items) {
      rows <- rows - 1L
      adjusted <- TRUE
    }

    if (cols > 1L && rows * (cols - 1L) >= n_items) {
      cols <- cols - 1L
      adjusted <- TRUE
    }

    if (!adjusted) {
      break
    }
  }

  list(nrow = rows, ncol = cols)
}

numeric_sync_state <- function(session) {
  state <- session$userData$ta_numeric_sync_state
  if (is.null(state) || !is.environment(state)) {
    state <- new.env(parent = emptyenv())
    session$userData$ta_numeric_sync_state <- state
  }
  state
}

mark_pending_numeric_update <- function(session, input_id) {
  state <- numeric_sync_state(session)
  key <- paste0("pending_", input_id)
  assign(key, TRUE, envir = state)
}

consume_pending_numeric_update <- function(session, input_id) {
  state <- numeric_sync_state(session)
  key <- paste0("pending_", input_id)
  if (!exists(key, envir = state, inherits = FALSE)) {
    return(FALSE)
  }

  pending <- get(key, envir = state, inherits = FALSE)
  if (isTRUE(pending)) {
    assign(key, FALSE, envir = state)
    return(TRUE)
  }

  FALSE
}

sync_numeric_input <- function(session, input_id, current_value, target_value) {
  if (is.null(target_value) || length(target_value) == 0) {
    return(invisible(FALSE))
  }

  target_int <- suppressWarnings(as.integer(target_value[1]))
  if (is.na(target_int)) {
    return(invisible(FALSE))
  }

  state <- numeric_sync_state(session)
  key <- paste0("input_", input_id)

  current_int <- suppressWarnings(as.integer(current_value[1]))
  missing_current <- length(current_value) == 0 || is.na(current_int)

  if (!exists(key, envir = state, inherits = FALSE)) {
    assign(key, list(value = NULL, auto = TRUE), envir = state)
  }

  entry <- get(key, envir = state, inherits = FALSE)

  if (missing_current) {
    assign(key, list(value = target_int, auto = TRUE), envir = state)
    mark_pending_numeric_update(session, input_id)
    session$onFlushed(function() {
      updateNumericInput(session, input_id, value = target_int)
    }, once = TRUE)
    return(invisible(TRUE))
  }

  if (!identical(current_int, entry$value)) {
    entry <- list(value = current_int, auto = FALSE)
    assign(key, entry, envir = state)
  }

  if (isTRUE(entry$auto) && !identical(current_int, target_int)) {
    assign(key, list(value = target_int, auto = TRUE), envir = state)
    mark_pending_numeric_update(session, input_id)
    session$onFlushed(function() {
      updateNumericInput(session, input_id, value = target_int)
    }, once = TRUE)
    return(invisible(TRUE))
  }

  invisible(FALSE)
}
# ===============================================================
# ðŸ§ª Table  Analyzer â€” Pairwise Correlation Module
# ===============================================================

ggpairs_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      with_help_tooltip(
        selectInput(ns("vars"), "Numeric variables", choices = NULL, multiple = TRUE),
        "Choose which numeric columns to include in the correlation matrix."
      ),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show correlation matrix", width = "100%"),
          "Calculate the correlation coefficients for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_model"), "Download all results", style = "width: 100%;"),
          "Export the correlation matrices and any messages to a text file."
        ))
      )
    ),
    results = tagList(
      h5("Correlation matrix"),
      verbatimTextOutput(ns("summary"))
    )
  )
}

ggpairs_server <- function(id, data_reactive) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(data_reactive())

    strat_info <- stratification_server("strat", df)

    # ---- Update variable selector ----
    observe({
      req(df())
      num_vars <- names(df())[sapply(df(), is.numeric)]
      updateSelectInput(session, "vars", choices = num_vars, selected = num_vars)
    })

    build_ggpairs_object <- function(data) {
      GGally::ggpairs(
        data,
        progress = FALSE,
        upper = list(
          continuous = GGally::wrap("cor", size = 4, color = basic_color_palette[1])
        ),
        lower = list(
          continuous = GGally::wrap("points", alpha = 0.6, color = basic_color_palette[1], size = 1.5)
        ),
        diag = list(
          continuous = GGally::wrap("densityDiag", fill = basic_color_palette[1], alpha = 0.4)
        )
      ) +
        ggplot2::theme_minimal(base_size = 11) +
        ggplot2::theme(
          strip.text = ggplot2::element_text(face = "bold", size = 9),
          panel.grid.minor = ggplot2::element_blank(),
          panel.grid.major.x = ggplot2::element_blank(),
          panel.grid.major.y = ggplot2::element_blank(),
          plot.title = ggplot2::element_text(size = 12, face = "bold")
        )
    }

    correlation_store <- reactiveVal(NULL)

    # ---- Compute correlation matrix ----
    observeEvent(input$run, {
      req(df())
      data <- df()
      numeric_vars <- names(data)[sapply(data, is.numeric)]
      selected_vars <- if (length(input$vars)) input$vars else numeric_vars
      selected_vars <- intersect(selected_vars, numeric_vars)

      if (length(selected_vars) < 2) {
        correlation_store(list(
          message = "Need at least two numeric columns.",
          matrices = list(),
          plots = list(),
          group_var = NULL,
          selected_vars = selected_vars,
          data_used = NULL,
          strata_levels = NULL
        ))
        return()
      }

      strat_details <- strat_info()
      group_var <- strat_details$var

      strata_levels <- "Overall"
      if (!is.null(group_var) && group_var %in% names(data)) {
        levels <- strat_details$levels
        if (is.null(levels) || length(levels) == 0) {
          values <- data[[group_var]]
          values <- values[!is.na(values)]
          strata_levels <- unique(as.character(values))
        } else {
          strata_levels <- levels
        }
      } else {
        group_var <- NULL
      }

      matrices <- list()
      plots <- list()
      processed_data <- data[, unique(c(selected_vars, group_var)), drop = FALSE]

      if (!is.null(group_var)) {
        keep_rows <- !is.na(processed_data[[group_var]]) &
          as.character(processed_data[[group_var]]) %in% strata_levels
        processed_data <- processed_data[keep_rows, , drop = FALSE]
        processed_data[[group_var]] <- factor(
          as.character(processed_data[[group_var]]),
          levels = strata_levels
        )
      }

      if (is.null(group_var)) {
        dat <- data[, selected_vars, drop = FALSE]
        cor_matrix <- cor(dat, use = "pairwise.complete.obs")
        matrices[["Overall"]] <- cor_matrix
        plots[["Overall"]] <- build_ggpairs_object(dat)
      } else {
        for (level in strata_levels) {
          subset_rows <- !is.na(data[[group_var]]) & as.character(data[[group_var]]) == level
          subset_data <- data[subset_rows, , drop = FALSE]
          if (nrow(subset_data) == 0) {
            matrices[[level]] <- NULL
            plots[[level]] <- NULL
            next
          }
          dat <- subset_data[, selected_vars, drop = FALSE]
          cor_matrix <- suppressWarnings(cor(dat, use = "pairwise.complete.obs"))
          matrices[[level]] <- cor_matrix
          plots[[level]] <- build_ggpairs_object(dat)
        }
      }

      correlation_store(list(
        matrices = matrices,
        plots = plots,
        group_var = group_var,
        selected_vars = selected_vars,
        data_used = processed_data,
        strata_levels = if (!is.null(group_var)) strata_levels else NULL
      ))
    })

    output$summary <- renderPrint({
      results <- correlation_store()
      if (is.null(results)) {
        return(invisible(NULL))
      }

      if (!is.null(results$message)) {
        cat(results$message)
        return(invisible(NULL))
      }

      matrices <- results$matrices
      if (is.null(matrices) || length(matrices) == 0) {
        return(invisible(NULL))
      }

      multiple <- length(matrices) > 1
      for (name in names(matrices)) {
        mat <- matrices[[name]]
        if (multiple) {
          cat(sprintf("=== Stratum: %s ===\n", name))
        }
        if (is.null(mat)) {
          cat("  No data available for this stratum.\n\n")
        } else {
          print(round(mat, 2))
          cat("\n")
        }
      }
    })
    
    # ---- Download results ----
    output$download_model <- downloadHandler(
      filename = function() paste0("Correlation_results_", Sys.Date(), ".txt"),
      content = function(file) {
        res <- correlation_store()
        if (is.null(res)) return()
        sink(file)
        on.exit(sink(), add = TRUE)
        
        if (!is.null(res$message)) {
          cat(res$message, "\n")
          return()
        }
        
        matrices <- res$matrices
        if (is.null(matrices) || length(matrices) == 0) {
          cat("No correlation matrices available.\n")
          return()
        }
        
        multiple <- length(matrices) > 1
        for (nm in names(matrices)) {
          mat <- matrices[[nm]]
          if (multiple) cat(sprintf("=== Stratum: %s ===\n", nm))
          if (is.null(mat)) {
            cat("No data available for this stratum.\n\n")
          } else {
            print(round(mat, 3))
            cat("\n")
          }
        }

      }
    )

    # ---- Return structured output for visualization ----
    df_final <- reactive({
      res <- correlation_store()
      if (is.null(res)) return(NULL)
      res$data_used
    })

    model_fit <- reactive({
      res <- correlation_store()
      if (is.null(res)) return(NULL)
      res$matrices
    })

    summary_table <- reactive({
      res <- correlation_store()
      if (is.null(res)) return(NULL)
      res$matrices
    })

    posthoc_results <- reactive(NULL)

    effect_table <- reactive(NULL)

    reactive({
      res <- correlation_store()
      if (is.null(res)) return(NULL)

      data_used <- df_final()

      list(
        analysis_type = "CORR",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = posthoc_results(),
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        metadata = list(
          selected_vars = res$selected_vars,
          group_var = res$group_var,
          strata_levels = res$strata_levels,
          plots = res$plots,
          message = res$message
        ),
        type = "pairs",
        data = df,
        group_var = reactive({
          det <- correlation_store()
          if (is.null(det)) return(NULL)
          det$group_var
        }),
        strata_order = reactive({
          det <- correlation_store()
          if (is.null(det)) return(NULL)
          det$strata_levels
        }),
        results = reactive(correlation_store())
      )
    })
  })
}
# ===============================================================
# ðŸ§ª Visualization Module â€” Pairwise Correlation (Dispatcher)
# ===============================================================

visualize_ggpairs_ui <- function(id) {
  ns <- NS(id)
  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize pairwise correlation"),
      p("Visualize pairwise relationships and correlation coefficients among numeric variables."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c("Pairwise scatterplot matrix" = "GGPairs"),
          selected = "GGPairs"
        ),
        "Choose how to visualise the pairwise relationships between variables."
      ),
      uiOutput(ns("sub_controls"))
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"), height = "auto")
    )
  )
}


visualize_ggpairs_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    correlation_info <- reactive({
      info <- model_fit()
      if (is.null(info) || is.null(info$type) || info$type != "pairs") {
        return(NULL)
      }
      info
    })

    active <- reactiveVal(NULL)

    output$sub_controls <- renderUI({
      info <- correlation_info()
      if (is.null(info)) {
        helpText("Run the pairwise correlation analysis to configure plots.")
      } else if (identical(input$plot_type, "GGPairs")) {
        pairwise_correlation_visualize_ggpairs_ui(ns("ggpairs"))
      } else {
        NULL
      }
    })

    observeEvent(list(input$plot_type, correlation_info()), {
      info <- correlation_info()
      type <- input$plot_type

      if (is.null(info) || is.null(type)) {
        active(NULL)
        return()
      }

      handle <- switch(type,
                       "GGPairs" = pairwise_correlation_visualize_ggpairs_server("ggpairs", filtered_data, correlation_info),
                       NULL)
      active(handle)
    }, ignoreNULL = FALSE)

    output$plot_warning <- renderUI({
      h <- active()
      if (is.null(h)) return(NULL)
      warning_text <- h$warning()
      if (!is.null(warning_text)) {
        div(class = "alert alert-warning", HTML(warning_text))
      } else {
        NULL
      }
    })

    output$plot <- renderPlot({
      h <- active()
      req(h)
      warning_text <- h$warning()
      if (!is.null(warning_text)) return(NULL)
      plot_obj <- h$plot()
      validate(need(!is.null(plot_obj), "No plot available."))
      print(plot_obj)
    },
    width = function() {
      h <- active()
      if (is.null(h)) 800 else h$width()
    },
    height = function() {
      h <- active()
      if (is.null(h)) 600 else h$height()
    },
    res = 96)
  })
}
# ===============================================================
# ðŸ§ª Pairwise Correlation â€” GGPairs Visualization Module
# ===============================================================

pairwise_correlation_visualize_ggpairs_ui <- function(id) {
  ns <- NS(id)
  tagList(
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("plot_width"),  "Subplot width (px)",  800, 200, 2000, 50),
        "Set the width in pixels for each panel of the correlation matrix."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("plot_height"), "Subplot height (px)", 600, 200, 2000, 50),
        "Set the height in pixels for each panel of the correlation matrix."
      ))
    ),
    fluidRow(
      column(6, with_help_tooltip(
        numericInput(ns("resp_rows"),    "Grid rows",    NA, 1, 10, 1),
        "Choose how many rows of panels to use when multiple strata are plotted."
      )),
      column(6, with_help_tooltip(
        numericInput(ns("resp_cols"),    "Grid columns", NA, 1, 10, 1),
        "Choose how many columns of panels to use when multiple strata are plotted."
      ))
    ),
    fluidRow(
      column(6, add_color_customization_ui(ns, multi_group = TRUE)),
      column(6, base_size_ui(
        ns,
        default = 11,
        help_text = "Adjust the base font size used for the correlation plot."
      ))
    ),
    hr(),
    with_help_tooltip(
      downloadButton(ns("download_plot"), "Download Plot", style = "width: 100%;"),
      "Save the current correlation figure as an image file."
    )
  )
}


pairwise_correlation_visualize_ggpairs_server <- function(id, filtered_data, correlation_info) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    resolve_input_value <- function(x) {
      if (is.null(x)) return(NULL)
      if (is.reactive(x)) x() else x
    }

    sanitize_numeric <- function(value, default, min_val, max_val) {
      v <- suppressWarnings(as.numeric(value))
      if (length(v) == 0 || is.na(v)) return(default)
      v <- max(min_val, min(max_val, v))
      v
    }

    plot_width <- reactive({
      sanitize_numeric(input$plot_width, 800, 200, 2000)
    })

    plot_height <- reactive({
      sanitize_numeric(input$plot_height, 600, 200, 2000)
    })

    color_var_reactive <- reactive({
      info <- correlation_info()
      if (is.null(info)) return(NULL)

      group_var <- resolve_input_value(info$group_var)
      if (is.null(group_var) || identical(group_var, "") || identical(group_var, "None")) {
        return(NULL)
      }

      dat <- filtered_data()
      if (is.null(dat) || !is.data.frame(dat) || !group_var %in% names(dat)) {
        return(NULL)
      }

      group_var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = filtered_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 11
    )

    build_ggpairs_plot <- function(data, color_value, title = NULL, base_size_value = 11) {
      validate(need(is.data.frame(data) && nrow(data) > 0, "No data available for plotting."))

      numeric_cols <- data[, vapply(data, is.numeric, logical(1)), drop = FALSE]
      numeric_cols <- numeric_cols[, colSums(!is.na(numeric_cols)) > 0, drop = FALSE]

      validate(need(ncol(numeric_cols) >= 2, "Need at least two numeric columns for GGPairs plot."))

      plot_obj <- GGally::ggpairs(
        numeric_cols,
        progress = FALSE,
        upper = list(
          continuous = GGally::wrap("cor", size = 4, colour = color_value)
        ),
        lower = list(
          continuous = GGally::wrap("points", alpha = 0.6, colour = color_value, size = 1.5)
        ),
        diag = list(
          continuous = GGally::wrap("densityDiag", fill = color_value, alpha = 0.4)
        )
      ) +
        ggplot2::theme_minimal(base_size = base_size_value) +
        ggplot2::theme(
          strip.text = ggplot2::element_text(face = "bold", size = 9),
          panel.grid.minor = ggplot2::element_blank(),
          panel.grid.major = ggplot2::element_blank()
        )

      if (!is.null(title)) {
        plot_obj <- plot_obj + ggplot2::labs(title = title)
      }

      plot_obj
    }

    convert_ggmatrix_to_plot <- function(plot_obj) {
      if (!inherits(plot_obj, "ggmatrix")) {
        return(plot_obj)
      }

      gtable <- GGally::ggmatrix_gtable(plot_obj)

      ggplot2::ggplot() +
        ggplot2::theme_void() +
        ggplot2::annotation_custom(
          grob = gtable,
          xmin = -Inf, xmax = Inf,
          ymin = -Inf, ymax = Inf
        )
    }

    plot_info <- reactive({
      info <- correlation_info()
      validate(need(!is.null(info), "Correlation results are not available."))

      results_accessor <- info$results
      results <- resolve_input_value(results_accessor)

      validate(need(!is.null(results), "Run the correlation analysis to generate plots."))

      if (!is.null(results$message)) {
        validate(need(FALSE, results$message))
      }

      data <- filtered_data()
      validate(need(!is.null(data) && nrow(data) > 0, "No data available."))

      selected_vars <- resolve_input_value(results$selected_vars)
      if (is.null(selected_vars) || length(selected_vars) < 2) {
        numeric_vars <- names(data)[vapply(data, is.numeric, logical(1))]
        selected_vars <- numeric_vars
      }

      validate(need(length(selected_vars) >= 2, "Need at least two numeric columns for GGPairs plot."))

      group_var <- resolve_input_value(info$group_var)
      if (is.null(group_var) || identical(group_var, "None") || identical(group_var, "")) {
        group_var <- NULL
      }

      strata_order <- resolve_input_value(info$strata_order)

      if (is.null(group_var)) {
        plot_data <- data[, selected_vars, drop = FALSE]
        color_choice <- resolve_single_color(custom_colors())
        plot_obj <- build_ggpairs_plot(plot_data, color_choice, base_size_value = base_size())
        defaults <- compute_default_grid(1L)
        layout <- list(nrow = defaults$rows, ncol = defaults$cols)
        list(
          plot = plot_obj,
          layout = layout,
          panels = 1L,
          warning = NULL,
          defaults = defaults
        )
      } else {
        available_levels <- NULL
        if (!is.null(results$matrices)) {
          available_levels <- names(results$matrices)
        }
        if (is.null(available_levels) || length(available_levels) == 0) {
          available_levels <- unique(as.character(data[[group_var]]))
        }
        if (!is.null(strata_order) && length(strata_order) > 0) {
          available_levels <- strata_order[strata_order %in% available_levels]
        }
        available_levels <- available_levels[nzchar(available_levels)]
        validate(need(length(available_levels) > 0, "No strata available for plotting."))

        colors <- resolve_palette_for_levels(available_levels, custom = custom_colors())

        plots <- list()
        for (level in available_levels) {
          subset_rows <- !is.na(data[[group_var]]) & as.character(data[[group_var]]) == level
          subset_data <- data[subset_rows, selected_vars, drop = FALSE]
          if (nrow(subset_data) == 0) {
            next
          }
          plots[[level]] <- convert_ggmatrix_to_plot(
            build_ggpairs_plot(
              subset_data,
              colors[[level]],
              title = level,
              base_size_value = base_size()
            )
          )
        }

        validate(need(length(plots) > 0, "No data available for the selected strata."))

        panel_count <- length(plots)
        defaults <- compute_default_grid(panel_count)

        layout <- basic_grid_layout(
          rows = suppressWarnings(as.numeric(input$resp_rows)),
          cols = suppressWarnings(as.numeric(input$resp_cols)),
          default_rows = defaults$rows,
          default_cols = defaults$cols
        )

        layout <- adjust_grid_layout(panel_count, layout)

        validation <- validate_grid(panel_count, layout$nrow, layout$ncol)

        combined <- NULL
        if (isTRUE(validation$valid)) {
          combined <- patchwork::wrap_plots(
            plotlist = plots,
            nrow = layout$nrow,
            ncol = layout$ncol
          )
        }

        list(
          plot = combined,
          layout = layout,
          panels = panel_count,
          warning = validation$message,
          defaults = defaults
        )
      }
    })

    plot_width_total <- reactive({
      info <- plot_info()
      layout <- info$layout
      w <- plot_width()
      if (!is.null(layout$ncol)) {
        w <- w * max(1L, as.integer(layout$ncol))
      }
      w
    })

    plot_height_total <- reactive({
      info <- plot_info()
      layout <- info$layout
      h <- plot_height()
      if (!is.null(layout$nrow)) {
        h <- h * max(1L, as.integer(layout$nrow))
      }
      h
    })

    observeEvent(plot_info(), {
      info <- plot_info()
      if (is.null(info) || is.null(info$defaults)) return()

      rows <- info$defaults$rows
      cols <- info$defaults$cols
      if (is.null(rows) || is.null(cols)) return()

      sync_numeric_input(session, "resp_rows", input$resp_rows, rows)
      sync_numeric_input(session, "resp_cols", input$resp_cols, cols)
    }, ignoreNULL = FALSE)

    output$download_plot <- downloadHandler(
      filename = function() paste0("pairwise_correlation_ggpairs_", Sys.Date(), ".png"),
      content = function(file) {
        info <- plot_info()
        req(is.null(info$warning))
        plot_obj <- info$plot
        req(plot_obj)
        ggplot2::ggsave(
          filename = file,
          plot = plot_obj,
          device = "png",
          dpi = 300,
          width = plot_width_total() / 96,
          height = plot_height_total() / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )

    list(
      plot = reactive({ plot_info()$plot }),
      width = reactive(plot_width_total()),
      height = reactive(plot_height_total()),
      warning = reactive(plot_info()$warning)
    )
  })
}
# ===============================================================
# ðŸ§ª Table Analyzer â€” PCA Module
# ===============================================================

pca_ui <- function(id) {
  ns <- NS(id)
  list(
    config = tagList(
      with_help_tooltip(
        selectInput(ns("vars"), "Numeric variables", choices = NULL, multiple = TRUE),
        "Pick the numeric variables whose combined patterns you want PCA to capture."
      ),
      tags$details(
        tags$summary(strong("Advanced options")),
        helpText(paste(
          "Stratify by is not available for PCA because the principal components are computed on the full numeric matrix.",
          "Splitting the data by groups would produce different coordinate systems, making the loadings and scores incomparable across groups."
        ))
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run_pca"), "Show PCA summary", width = "100%"),
          "Compute the principal components for the selected variables."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_all"), "Download all results", style = "width: 100%;"),
          "Export the PCA summaries, loadings, and diagnostics to a text file."
        ))
      )
    ),
    results = tagList(
      h5("PCA summary and loadings"),
      verbatimTextOutput(ns("summary")),
      uiOutput(ns("excluded_rows_section"))
    )
  )
}

pca_server <- function(id, filtered_data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    df <- reactive(filtered_data())

    # Dynamically populate numeric variable list
    observe({
      num_vars <- names(df())[sapply(df(), is.numeric)]
      updateSelectInput(session, "vars", choices = num_vars, selected = num_vars)
    })

    run_pca_on_subset <- function(subset_data, selected_vars) {
      if (is.null(subset_data) || nrow(subset_data) == 0) {
        return(list(model = NULL, data = subset_data, message = "No data available for PCA."))
      }

      numeric_subset <- subset_data[, selected_vars, drop = FALSE]
      complete_idx <- stats::complete.cases(numeric_subset)
      numeric_subset <- numeric_subset[complete_idx, , drop = FALSE]
      plot_data <- subset_data[complete_idx, , drop = FALSE]
      original_n <- nrow(subset_data)
      used_n <- nrow(plot_data)
      excluded_n <- original_n - used_n

      excluded_rows <- subset_data[!complete_idx, , drop = FALSE]
      if (excluded_n > 0) {
        excluded_rows <- cbind(
          data.frame(`Row #` = seq_len(nrow(subset_data))[!complete_idx], check.names = FALSE),
          excluded_rows
        )
        rownames(excluded_rows) <- NULL
      } else {
        excluded_rows <- NULL
      }

      if (nrow(numeric_subset) < 2) {
        return(list(
          model = NULL,
          data = plot_data,
          message = "Not enough complete observations to compute PCA.",
          original_n = original_n,
          used_n = used_n,
          excluded_n = excluded_n,
          excluded_rows = excluded_rows
        ))
      }

      safe_prcomp <- purrr::safely(function(mat) {
        prcomp(mat, center = TRUE, scale. = TRUE)
      })

      model <- safe_prcomp(numeric_subset)

      if (!is.null(model$error)) {
        return(list(
          model = NULL,
          data = plot_data,
          message = conditionMessage(model$error),
          message_title = "PCA computation failed",
          original_n = original_n,
          used_n = used_n,
          excluded_n = excluded_n,
          excluded_rows = excluded_rows
        ))
      }

      list(
        model = model$result,
        data = plot_data,
        message = NULL,
        original_n = original_n,
        used_n = used_n,
        excluded_n = excluded_n,
        excluded_rows = excluded_rows
      )
    }

    # Run PCA
    pca_result <- eventReactive(input$run_pca, {
      req(df())

      data <- df()
      validate(need(nrow(data) > 0, "No data available for PCA."))

      numeric_vars <- names(data)[vapply(data, is.numeric, logical(1))]
      selected_vars <- intersect(input$vars, numeric_vars)
      validate(need(length(selected_vars) > 1, "Select at least two numeric variables for PCA."))

      result <- run_pca_on_subset(data, selected_vars)

      list(
        selected_vars = selected_vars,
        result = result,
        data_used = result$data
      )
    })

    # Verbatim output: summary + loadings
    output$summary <- renderPrint({
      results <- pca_result()
      validate(need(!is.null(results), "Run the PCA analysis to view results."))

      entry <- results$result
      if (is.null(entry) || is.null(entry$model)) {
        if (!is.null(entry)) {
          used_n <- if (!is.null(entry$used_n)) entry$used_n else 0
          original_n <- if (!is.null(entry$original_n)) entry$original_n else 0
          excluded_n <- if (!is.null(entry$excluded_n)) entry$excluded_n else 0
          cat(sprintf(
            "Rows used for PCA: %d of %d (excluded %d due to missing values in the selected variables).\n\n",
            used_n,
            original_n,
            excluded_n
          ))
        }

        if (!is.null(entry) && !is.null(entry$message) && nzchar(entry$message)) {
          if (!is.null(entry$message_title)) {
            cat(format_safe_error_message(entry$message_title, entry$message))
          } else {
            cat(entry$message)
          }
        } else {
          cat("Not enough data to compute PCA.")
        }
        return(invisible())
      }

      model <- entry$model
      cat(sprintf(
        "Rows used for PCA: %d of %d (excluded %d due to missing values in the selected variables).\n\n",
        entry$used_n,
        entry$original_n,
        entry$excluded_n
      ))
      cat("â”€â”€ PCA Summary â”€â”€\n")
      print(summary(model))
      cat("\nâ”€â”€ PCA Loadings (rotation matrix) â”€â”€\n")
      print(round(model$rotation, 3))
      cat("\nâ”€â”€ PCA Explained Variance (%) â”€â”€\n")
      var_exp <- 100 * model$sdev^2 / sum(model$sdev^2)
      print(round(var_exp, 2))
      cat("\n")

      invisible()
    })

    # Download combined results
    output$download_all <- downloadHandler(
      filename = function() paste0("PCA_results_", Sys.Date(), ".txt"),
      content = function(file) {
        results <- pca_result()
        req(results)

        sink(file)
        on.exit(sink(), add = TRUE)

        entry <- results$result
        if (!is.null(entry)) {
          used_n <- if (!is.null(entry$used_n)) entry$used_n else 0
          original_n <- if (!is.null(entry$original_n)) entry$original_n else 0
          excluded_n <- if (!is.null(entry$excluded_n)) entry$excluded_n else 0
          cat(sprintf(
            "Rows used for PCA: %d of %d (excluded %d due to missing values in the selected variables).\n\n",
            used_n,
            original_n,
            excluded_n
          ))
        }

        if (is.null(entry) || is.null(entry$model)) {
          if (!is.null(entry) && !is.null(entry$message) && nzchar(entry$message)) {
            if (!is.null(entry$message_title)) {
              cat(format_safe_error_message(entry$message_title, entry$message), "\n", sep = "")
            } else {
              cat(entry$message, "\n", sep = "")
            }
          } else {
            cat("Not enough data to compute PCA.\n")
          }
          return()
        }

        model <- entry$model
        cat("â”€â”€ PCA Summary â”€â”€\n")
        print(summary(model))
        cat("\nâ”€â”€ PCA Loadings (rotation matrix) â”€â”€\n")
        print(round(model$rotation, 3))
        cat("\nâ”€â”€ PCA Explained Variance (%) â”€â”€\n")
        var_exp <- 100 * model$sdev^2 / sum(model$sdev^2)
        print(round(var_exp, 2))
        cat("\n")
      }
    )

    # Return structured reactive for integration
    df_final <- reactive({
      details <- pca_result()
      if (is.null(details)) return(NULL)
      details$data_used
    })

    model_fit <- reactive({
      details <- pca_result()
      if (is.null(details)) return(NULL)
      details$result
    })

    compiled_tables <- reactive({
      details <- pca_result()
      if (is.null(details)) return(NULL)

      entry <- details$result
      if (is.null(entry)) return(NULL)

      messages_list <- if (!is.null(entry$message)) list(PCA = entry$message) else NULL

      model <- entry$model
      if (is.null(model)) {
        return(list(summary = NULL, effects = NULL, messages = messages_list))
      }

      rotation_tbl <- as.data.frame(as.table(model$rotation), stringsAsFactors = FALSE)
      colnames(rotation_tbl) <- c("Variable", "Component", "Loading")

      variance_vals <- 100 * model$sdev^2 / sum(model$sdev^2)
      variance_tbl <- data.frame(
        Component = paste0("PC", seq_along(variance_vals)),
        Variance = variance_vals,
        stringsAsFactors = FALSE
      )

      list(
        summary = list(PCA = rotation_tbl),
        effects = list(PCA = variance_tbl),
        messages = messages_list
      )
    })

    summary_table <- reactive({
      res <- compiled_tables()
      if (is.null(res)) return(NULL)
      res$summary
    })

    effect_table <- reactive({
      res <- compiled_tables()
      if (is.null(res)) return(NULL)
      res$effects
    })

    posthoc_results <- reactive(NULL)

    analysis_result <- reactive({
      details <- pca_result()
      if (is.null(details)) {
        return(list(
          analysis_type = "PCA",
          data_used = df(),
          model = NULL,
          summary = NULL,
          posthoc = NULL,
          effects = NULL,
          stats = if (!is.null(df())) list(n = nrow(df()), vars = names(df())) else NULL,
          metadata = list(
            selected_vars = input$vars,
            group_var = NULL,
            strata_levels = NULL,
            messages = NULL,
            complete_cases = NULL,
            excluded_rows = NULL,
            excluded_n = NULL,
            original_n = NULL
          ),
          type = "pca",
          data = df,
          vars = input$vars,
          selected_vars = input$vars,
          group_var = NULL,
          strata_levels = NULL
        ))
      }

      data_used <- df_final()

      compiled <- compiled_tables()
      messages <- if (!is.null(compiled)) compiled$messages else NULL

      entry <- details$result

      list(
        analysis_type = "PCA",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = posthoc_results(),
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        metadata = list(
          selected_vars = details$selected_vars,
          group_var = NULL,
          strata_levels = NULL,
          complete_cases = if (!is.null(entry)) entry$data else NULL,
          excluded_rows = if (!is.null(entry)) entry$excluded_rows else NULL,
          excluded_n = if (!is.null(entry)) entry$excluded_n else NULL,
          original_n = if (!is.null(entry)) entry$original_n else NULL,
          messages = messages
        ),
        type = "pca",
        data = df,
        vars = details$selected_vars,
        selected_vars = details$selected_vars,
        group_var = NULL,
        strata_levels = NULL
      )
    })

    output$excluded_rows_section <- renderUI({
      results <- pca_result()
      req(results)

      entry <- results$result
      if (is.null(entry) || is.null(entry$excluded_n) || entry$excluded_n == 0) {
        return(tags$p("No rows were excluded when computing the PCA."))
      }

      tagList(
        h5(sprintf("Excluded rows (%d)", entry$excluded_n)),
        DT::DTOutput(ns("excluded_table"))
      )
    })

    output$excluded_table <- DT::renderDT({
      results <- pca_result()
      req(results)

      entry <- results$result
      req(entry$excluded_rows)

      DT::datatable(
        entry$excluded_rows,
        options = list(scrollX = TRUE, pageLength = 5),
        rownames = FALSE,
        class = "compact stripe"
      )
    })

    analysis_result
  })
}
# ===============================================================
# Visualization Module - PCA (Biplot)
# ===============================================================

# Helper to detect categorical columns ----------------------------------------
.is_categorical <- function(x) {
  is.factor(x) || is.character(x) || is.logical(x)
}

.pca_aesthetic_choices <- function(data) {
  if (missing(data) || is.null(data) || !is.data.frame(data) || ncol(data) == 0) {
    return(c("None" = "None"))
  }

  keep <- vapply(data, .is_categorical, logical(1))
  cat_cols <- names(data)[keep]

  if (length(cat_cols) == 0) {
    return(c("None" = "None"))
  }

  c("None" = "None", stats::setNames(cat_cols, cat_cols))
}

visualize_pca_ui <- function(id, filtered_data = NULL) {
  ns <- NS(id)
  choices <- .pca_aesthetic_choices(filtered_data)

  sidebarLayout(
    sidebarPanel(
      width = 4,
      h4("Step 4 â€” Visualize principal component analysis (PCA)"),
      p("Visualize multivariate structure using a PCA biplot."),
      hr(),
      with_help_tooltip(
        selectInput(
          ns("plot_type"),
          label = "Select visualization type",
          choices = c("PCA biplot" = "biplot"),
          selected = "biplot"
        ),
        "Pick how the PCA results should be displayed."
      ),
      with_help_tooltip(
        selectInput(
          ns("pca_color"),
          label = "Color points by",
          choices = choices,
          selected = "None"
        ),
        "Colour the samples using a grouping variable to spot patterns."
      ),
      with_help_tooltip(
        selectInput(
          ns("pca_shape"),
          label = "Shape points by",
          choices = choices,
          selected = "None"
        ),
        "Change the point shapes using a grouping variable for extra contrast."
      ),
      with_help_tooltip(
        selectInput(
          ns("pca_label"),
          label = "Label points by",
          choices = choices,
          selected = "None"
        ),
        "Add text labels from a column to identify each sample."
      ),
      with_help_tooltip(
        selectInput(
          ns("facet_var"),
          label = "Facet by variable",
          choices = choices,
          selected = "None"
        ),
        "Split the plot into small multiples based on a grouping variable."
      ),
      uiOutput(ns("layout_controls")),
      with_help_tooltip(
        numericInput(
          ns("pca_label_size"),
          label = "Label size",
          value = 2,
          min = 0.5,
          max = 6,
          step = 0.5
        ),
        "Control how large the point labels appear on the plot."
      ),
      with_help_tooltip(
        checkboxInput(
          ns("show_loadings"),
          label = "Show loadings",
          value = FALSE
        ),
        "Display arrows that show how each original variable contributes to the components."
      ),
      with_help_tooltip(
        numericInput(
          ns("loading_scale"),
          label = "Loading arrow scale",
          value = 1.2, min = 0.1, max = 5, step = 0.1
        ),
        "Stretch or shrink the loading arrows to make them easier to read."
      ),
      fluidRow(
        column(
          width = 6,
          with_help_tooltip(
            numericInput(
              ns("plot_width"),
              label = "Plot width (px)",
              value = 800,
              min = 200,
              max = 2000,
              step = 50
            ),
            "Set the width of the PCA plot in pixels."
          )
        ),
        column(
          width = 6,
          with_help_tooltip(
            numericInput(
              ns("plot_height"),
              label = "Plot height (px)",
              value = 600,
              min = 200,
              max = 2000,
              step = 50
            ),
            "Set the height of the PCA plot in pixels."
          )
        )
      ),
      fluidRow(
        column(6, add_color_customization_ui(ns, multi_group = TRUE)),
        column(6, base_size_ui(
          ns,
          default = 14,
          help_text = "Adjust the base font size used for PCA plots."
        ))
      ),
      br(),
      with_help_tooltip(
        downloadButton(ns("download_plot"), "Download plot", style = "width: 100%;"),
        "Save the PCA figure as an image file."
      )
    ),
    mainPanel(
      width = 8,
      h4("Plots"),
      uiOutput(ns("plot_warning")),
      plotOutput(ns("plot"))
    )
  )
}

visualize_pca_server <- function(id, filtered_data, model_fit) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    # -- Reactives ------------------------------------------------------------
    model_info <- reactive({
      info <- model_fit()
      validate(need(!is.null(info) && identical(info$type, "pca"), "Run PCA first."))
      info
    })

    pca_entry <- reactive({
      info <- model_info()
      entry <- info$model
      validate(need(!is.null(entry), "PCA model missing."))
      entry
    })

    validate_choice <- function(value, pool) {
      if (is.null(value) || identical(value, "None") || !nzchar(value)) {
        return(NULL)
      }
      if (length(pool) == 0 || !(value %in% pool)) {
        return(NULL)
      }
      value
    }

    available_choices <- reactive({
      data <- color_data()
      .pca_aesthetic_choices(data)
    })

    color_data <- reactive({
      entry <- pca_entry()
      if (!is.null(entry) && !is.null(entry$data)) {
        entry$data
      } else if (!is.null(filtered_data)) {
        if (is.reactive(filtered_data)) {
          filtered_data()
        } else {
          filtered_data
        }
      } else {
        NULL
      }
    })

    color_var_reactive <- reactive({
      var <- input$pca_color
      if (is.null(var) || identical(var, "None") || !nzchar(var)) {
        return(NULL)
      }

      data <- color_data()
      if (is.null(data) || !is.data.frame(data) || !var %in% names(data)) {
        return(NULL)
      }

      var
    })

    custom_colors <- add_color_customization_server(
      ns = ns,
      input = input,
      output = output,
      data = color_data,
      color_var_reactive = color_var_reactive,
      multi_group = TRUE
    )

    base_size <- base_size_server(
      input = input,
      default = 14
    )

    observeEvent(available_choices(), {
      choices <- available_choices()

      select_valid <- function(current) {
        if (!is.null(current) && current %in% choices) {
          current
        } else {
          "None"
        }
      }

      updateSelectInput(session, "pca_color", choices = choices, selected = select_valid(input$pca_color))
      updateSelectInput(session, "pca_shape", choices = choices, selected = select_valid(input$pca_shape))
      updateSelectInput(session, "pca_label", choices = choices, selected = select_valid(input$pca_label))
    }, ignoreNULL = FALSE)

    observeEvent(available_choices(), {
      facet_choices <- available_choices()

      selected <- if (!is.null(input$facet_var) && input$facet_var %in% facet_choices) {
        input$facet_var
      } else {
        "None"
      }

      updateSelectInput(session, "facet_var", choices = facet_choices, selected = selected)
    }, ignoreNULL = FALSE)

    output$layout_controls <- renderUI({
      facet_info <- facet_selection()
      if (is.null(facet_info$var) || length(facet_info$levels) <= 1) {
        return(NULL)
      }

      ns <- session$ns
      tagList(
        fluidRow(
          column(
            width = 6,
            with_help_tooltip(
              numericInput(
                ns("grid_rows"),
                "Grid rows",
                value = isolate(if (is.null(input$grid_rows)) NA else input$grid_rows),
                min = 1,
                max = 10,
                step = 1
              ),
              "Decide how many rows of panels to show when faceting the PCA plot."
            )
          ),
          column(
            width = 6,
            with_help_tooltip(
              numericInput(
                ns("grid_cols"),
                "Grid columns",
                value = isolate(if (is.null(input$grid_cols)) NA else input$grid_cols),
                min = 1,
                max = 10,
                step = 1
              ),
              "Decide how many columns of panels to show when faceting the PCA plot."
            )
          )
        )
      )
    })
    facet_selection <- reactive({
      data <- color_data()
      facet_var <- input$facet_var

      if (is.null(data) || !is.data.frame(data) || nrow(data) == 0) {
        return(list(var = NULL, levels = NULL, column = NULL))
      }

      if (is.null(facet_var) || identical(facet_var, "None") || !nzchar(facet_var)) {
        return(list(var = NULL, levels = NULL, column = NULL))
      }

      if (!facet_var %in% names(data)) {
        return(list(var = NULL, levels = NULL, column = NULL))
      }

      column <- data[[facet_var]]
      if (is.null(column)) {
        return(list(var = NULL, levels = NULL, column = NULL))
      }

      if (is.factor(column)) {
        levels <- levels(droplevels(column))
      } else {
        column_chr <- as.character(column)
        column_chr <- column_chr[!is.na(column_chr)]
        levels <- unique(column_chr)
      }

      levels <- levels[!is.na(levels)]

      list(var = facet_var, levels = levels, column = column)
    })

    build_message_panel <- function(title, message, show_title = TRUE) {
      base_plot <- ggplot() +
        theme_void() +
        annotate(
          "text",
          x = 0.5,
          y = 0.5,
          label = message,
          size = 4,
          hjust = 0.5,
          vjust = 0.5
        ) +
        coord_cartesian(xlim = c(0, 1), ylim = c(0, 1), clip = "off")

      if (isTRUE(show_title) && !is.null(title) && nzchar(title)) {
        base_plot +
          labs(title = title) +
          theme(plot.title = element_text(size = 14, face = "bold", hjust = 0.5))
      } else {
        base_plot +
          theme(plot.title = element_blank())
      }
    }

    sanitize_suffix <- function(value) {
      value <- value[1]
      safe <- gsub("[^A-Za-z0-9]+", "_", value)
      safe <- gsub("_+", "_", safe)
      safe <- gsub("^_|_$", "", safe)
      if (!nzchar(safe)) {
        "facet"
      } else {
        tolower(safe)
      }
    }

    plot_info <- reactive({
      req(input$plot_type)
      validate(need(input$plot_type == "biplot", "Unsupported plot type."))

      entry <- pca_entry()

      if (is.null(entry) || is.null(entry$model)) {
        message_text <- if (!is.null(entry$message) && nzchar(entry$message)) entry$message else "No PCA results available."
        message_plot <- build_message_panel(title = NULL, message = message_text, show_title = FALSE)
        defaults <- compute_default_grid(1L)
        layout <- basic_grid_layout(rows = 1, cols = 1, default_rows = 1, default_cols = 1)
        return(list(
          plot = message_plot,
          layout = layout,
          facet_levels = NULL,
          panels = 1L,
          warning = NULL,
          defaults = defaults,
          facet_var = NULL
        ))
      }

      if (is.null(entry$model$x) || nrow(entry$model$x) < 2) {
        message_plot <- build_message_panel(title = NULL, message = "PCA scores not available.", show_title = FALSE)
        defaults <- compute_default_grid(1L)
        layout <- basic_grid_layout(rows = 1, cols = 1, default_rows = 1, default_cols = 1)
        return(list(
          plot = message_plot,
          layout = layout,
          facet_levels = NULL,
          panels = 1L,
          warning = NULL,
          defaults = defaults,
          facet_var = NULL
        ))
      }

      data <- entry$data
      if (is.null(data) || nrow(data) == 0) {
        message_plot <- build_message_panel(title = NULL, message = "PCA data unavailable.", show_title = FALSE)
        defaults <- compute_default_grid(1L)
        layout <- basic_grid_layout(rows = 1, cols = 1, default_rows = 1, default_cols = 1)
        return(list(
          plot = message_plot,
          layout = layout,
          facet_levels = NULL,
          panels = 1L,
          warning = NULL,
          defaults = defaults,
          facet_var = NULL
        ))
      }

      choices <- available_choices()
      choice_pool <- unname(choices)
      color_var <- validate_choice(input$pca_color, choice_pool)
      shape_var <- validate_choice(input$pca_shape, choice_pool)
      label_var <- validate_choice(input$pca_label, choice_pool)
      label_size <- ifelse(is.null(input$pca_label_size) || is.na(input$pca_label_size), 2, input$pca_label_size)
      show_loadings <- isTRUE(input$show_loadings)
      loading_scale <- ifelse(is.null(input$loading_scale) || is.na(input$loading_scale), 1.2, input$loading_scale)

      facet_info <- facet_selection()
      facet_var <- facet_info$var
      facet_levels <- facet_info$levels
      facet_column <- facet_info$column

      subset_list <- list(All = seq_len(nrow(data)))
      if (!is.null(facet_var) && length(facet_levels) > 0) {
        subset_list <- list()
        facet_values <- if (is.factor(facet_column)) as.character(facet_column) else as.character(facet_column)
        for (level in facet_levels) {
          idx <- which(!is.na(facet_values) & facet_values == level)
          subset_list[[level]] <- idx
        }
      } else if (!is.null(facet_var)) {
        subset_list <- list(`No data` = integer())
      }

      color_levels <- NULL
      if (!is.null(color_var) && color_var %in% names(data)) {
        color_column <- data[[color_var]]
        if (is.factor(color_column)) {
          color_levels <- levels(droplevels(color_column))
        } else {
          color_chr <- as.character(color_column)
          color_levels <- unique(color_chr[!is.na(color_chr)])
        }
      }

      scores <- as.data.frame(entry$model$x[, 1:2, drop = FALSE])
      names(scores)[1:2] <- c("PC1", "PC2")

      adjust_limits <- function(lims) {
        if (length(lims) != 2 || any(!is.finite(lims))) {
          return(c(-1, 1))
        }
        if (diff(range(lims)) == 0) {
          center <- lims[1]
          width <- if (abs(center) < 1) 1 else abs(center) * 0.1
          return(c(center - width, center + width))
        }
        lims
      }

      x_limits <- adjust_limits(range(scores$PC1, na.rm = TRUE))
      y_limits <- adjust_limits(range(scores$PC2, na.rm = TRUE))

      plot_list <- list()

      for (key in names(subset_list)) {
        idx <- subset_list[[key]]

        if (length(idx) == 0) {
          plot_list[[key]] <- build_message_panel(title = key, message = "No data available for this facet.", show_title = TRUE)
          next
        }

        local_color <- if (!is.null(color_var) && color_var %in% names(data)) color_var else NULL
        local_shape <- if (!is.null(shape_var) && shape_var %in% names(data)) shape_var else NULL
        local_label <- if (!is.null(label_var) && label_var %in% names(data)) label_var else NULL

        plot_obj <- build_pca_biplot(
          pca_obj = entry$model,
          data = data,
          color_var = local_color,
          shape_var = local_shape,
          label_var = local_label,
          label_size = label_size,
          show_loadings = show_loadings,
          loading_scale = loading_scale,
          custom_colors = custom_colors(),
          subset_rows = idx,
          color_levels = color_levels,
          x_limits = x_limits,
          y_limits = y_limits,
          base_size = base_size()
        )

        if (!is.null(facet_var)) {
          plot_obj <- plot_obj +
            ggtitle(key) +
            theme(plot.title = element_text(size = 14, face = "bold"))
        }

        plot_list[[key]] <- plot_obj
      }

      plot_list <- Filter(Negate(is.null), plot_list)
      validate(need(length(plot_list) > 0, "No PCA plots available."))

      panel_count <- length(plot_list)
      defaults <- compute_default_grid(panel_count)

      use_custom_layout <- !is.null(facet_var) && panel_count > 1
      rows_input <- if (use_custom_layout) suppressWarnings(as.numeric(input$grid_rows)) else NA
      cols_input <- if (use_custom_layout) suppressWarnings(as.numeric(input$grid_cols)) else NA

      layout <- basic_grid_layout(
        rows = rows_input,
        cols = cols_input,
        default_rows = defaults$rows,
        default_cols = defaults$cols
      )

      validation <- validate_grid(panel_count, layout$nrow, layout$ncol)

      combined <- NULL
      if (isTRUE(validation$valid)) {
        combined <- patchwork::wrap_plots(
          plotlist = plot_list,
          nrow = layout$nrow,
          ncol = layout$ncol
        ) +
          patchwork::plot_layout(guides = "collect")
      }

      list(
        plot = combined,
        layout = layout,
        facet_levels = if (!is.null(facet_var)) names(plot_list) else NULL,
        panels = panel_count,
        warning = validation$message,
        defaults = defaults,
        facet_var = facet_var
      )
    })

    plot_size <- reactive({
      width <- suppressWarnings(as.numeric(input$plot_width))
      height <- suppressWarnings(as.numeric(input$plot_height))
      info <- plot_info()
      layout <- info$layout

      subplot_w <- ifelse(is.na(width) || width <= 0, 400, width)
      subplot_h <- ifelse(is.na(height) || height <= 0, 300, height)

      ncol <- if (!is.null(layout) && !is.null(layout$ncol)) max(1, layout$ncol) else 1
      nrow <- if (!is.null(layout) && !is.null(layout$nrow)) max(1, layout$nrow) else 1

      list(
        w = subplot_w * ncol,
        h = subplot_h * nrow
      )
    })

    observeEvent(plot_info(), {
      info <- plot_info()
      if (is.null(info) || is.null(info$defaults)) return()
      if (is.null(info$facet_var) || info$panels <= 1) return()

      rows <- info$defaults$rows
      cols <- info$defaults$cols
      if (is.null(rows) || is.null(cols)) return()

      sync_numeric_input(session, "grid_rows", input$grid_rows, rows)
      sync_numeric_input(session, "grid_cols", input$grid_cols, cols)
    }, ignoreNULL = FALSE)

    output$plot_warning <- renderUI({
      info <- plot_info()
      if (!is.null(info$warning)) {
        div(class = "alert alert-warning", info$warning)
      } else {
        NULL
      }
    })

    plot_obj <- reactive({
      info <- plot_info()
      if (!is.null(info$warning) || is.null(info$plot)) {
        return(NULL)
      }
      info$plot
    })

    output$plot <- renderPlot({
      info <- plot_info()
      if (!is.null(info$warning) || is.null(info$plot)) return(NULL)
      info$plot
    },
    width = function() plot_size()$w,
    height = function() plot_size()$h,
    res = 96)

    output$download_plot <- downloadHandler(
      filename = function() {
        info <- plot_info()
        facet_var <- info$facet_var
        suffix <- if (!is.null(facet_var)) {
          paste0("_facet_", sanitize_suffix(facet_var))
        } else {
          "_global"
        }
        paste0("pca_biplot", suffix, "_", Sys.Date(), ".png")
      },
      content = function(file) {
        info <- plot_info()
        req(is.null(info$warning))
        size <- plot_size()

        ggsave(
          filename = file,
          plot = info$plot,
          device = "png",
          dpi = 300,
          width = size$w / 96,
          height = size$h / 96,
          units = "in",
          limitsize = FALSE
        )
      }
    )
  })
}


build_pca_biplot <- function(pca_obj, data, color_var = NULL, shape_var = NULL,
                             label_var = NULL, label_size = 2,
                             show_loadings = FALSE, loading_scale = 1.2,
                             custom_colors = NULL, subset_rows = NULL,
                             color_levels = NULL, x_limits = NULL,
                             y_limits = NULL, base_size = 14) {
  stopifnot(!is.null(pca_obj$x))

  scores <- as.data.frame(pca_obj$x[, 1:2])
  names(scores)[1:2] <- c("PC1", "PC2")

  if (!is.null(subset_rows)) {
    subset_rows <- unique(subset_rows)
    subset_rows <- subset_rows[subset_rows >= 1 & subset_rows <= nrow(scores)]
    scores <- scores[subset_rows, , drop = FALSE]
    if (!is.null(data)) {
      data <- data[subset_rows, , drop = FALSE]
    }
  }

  var_exp <- 100 * (pca_obj$sdev^2 / sum(pca_obj$sdev^2))
  x_lab <- sprintf("PC1 (%.1f%%)", var_exp[1])
  y_lab <- sprintf("PC2 (%.1f%%)", var_exp[2])

  if (!is.null(data) && nrow(data) == nrow(scores)) {
    plot_data <- cbind(scores, data)
  } else {
    plot_data <- scores
  }
  
  if (!is.null(label_var) && !identical(label_var, "") && !is.null(plot_data[[label_var]])) {
    label_values <- as.character(plot_data[[label_var]])
    label_values[is.na(label_values) | trimws(label_values) == ""] <- NA_character_
    if (any(!is.na(label_values))) {
      plot_data$label_value <- label_values
    } else {
      label_var <- NULL
    }
  } else {
    label_var <- NULL
  }
  
  if (!is.null(color_var) && !is.null(plot_data[[color_var]])) {
    if (is.null(color_levels)) {
      color_levels <- if (is.factor(plot_data[[color_var]])) {
        levels(plot_data[[color_var]])
      } else {
        unique(as.character(plot_data[[color_var]]))
      }
    }
    color_levels <- unique(color_levels[!is.na(color_levels)])
    plot_data[[color_var]] <- factor(as.character(plot_data[[color_var]]), levels = color_levels)
  }
  
  aes_mapping <- aes(x = PC1, y = PC2)
  if (!is.null(color_var)) aes_mapping <- modifyList(aes_mapping, aes(color = .data[[color_var]]))
  if (!is.null(shape_var)) aes_mapping <- modifyList(aes_mapping, aes(shape = .data[[shape_var]]))
  
  single_color <- resolve_single_color(custom_colors)
  g <- ggplot(plot_data, aes_mapping) +
    geom_point(
      size = 3,
      shape = if (is.null(shape_var)) 16 else NULL,
      color = if (is.null(color_var)) single_color else NULL
    ) +
    theme_minimal(base_size = base_size) +
    labs(
      x = x_lab,
      y = y_lab,
      color = if (!is.null(color_var)) color_var else NULL,
      shape = if (!is.null(shape_var)) shape_var else NULL
    ) +
    theme(
      plot.title = element_text(size = 16, face = "bold"),
      legend.position = "right"
    )
  
  if (!is.null(color_var)) {
    palette <- resolve_palette_for_levels(levels(plot_data[[color_var]]), custom = custom_colors)
    g <- g + scale_color_manual(values = palette)
  }
  
  if (!is.null(x_limits) || !is.null(y_limits)) {
    g <- g + coord_cartesian(xlim = x_limits, ylim = y_limits)
  }

  if (!is.null(label_var)) {
    g <- g + ggrepel::geom_text_repel(
      aes(label = label_value),
      color = if (is.null(color_var)) single_color else NULL,
      size = label_size,
      max.overlaps = Inf,
      min.segment.length = 0,
      box.padding = 0.3,
      point.padding = 0.2,
      segment.size = 0.2,
      na.rm = TRUE
    )
  }
  
  # ---- Loadings as arrows (optional) ----
  if (isTRUE(show_loadings) && !is.null(pca_obj$rotation)) {
    R <- as.data.frame(pca_obj$rotation[, 1:2, drop = FALSE])
    R$variable <- rownames(pca_obj$rotation)
    
    # scale arrows to score space
    rx <- diff(range(pca_obj$x[, 1], na.rm = TRUE))
    ry <- diff(range(pca_obj$x[, 2], na.rm = TRUE))
    sx <- ifelse(is.finite(rx) && rx > 0, rx, 1)
    sy <- ifelse(is.finite(ry) && ry > 0, ry, 1)
    
    arrows_df <- transform(
      R,
      x = 0, y = 0,
      xend = PC1 * sx * loading_scale,
      yend = PC2 * sy * loading_scale
    )
    
    g <- g +
      geom_segment(
        data = arrows_df,
        aes(x = x, y = y, xend = xend, yend = yend),
        inherit.aes = FALSE,
        arrow = grid::arrow(length = grid::unit(0.02, "npc")),
        linewidth = 0.4,
        color = "grey30"
      ) +
      ggrepel::geom_text_repel(
        data = arrows_df,
        aes(x = xend, y = yend, label = variable),
        inherit.aes = FALSE,
        size = 3,
        color = "grey20",
        max.overlaps = Inf,
        segment.size = 0.2,
        box.padding = 0.2,
        point.padding = 0.2
      )
  }
  
  g
}
# ===============================================================
# ðŸ§¬ Common module for LM and LMM
# ===============================================================

reg_diagnostic_explanation <- paste(
  "The Residuals vs Fitted plot shows how far the model's predictions are from the observed values.",
  "A healthy model has points that bounce randomly around the dashed zero line; clear curves or a funnel shape mean the model is missing structure or the error size changes across fitted values.",
  "The Normal Q-Q plot checks whether the residuals follow a roughly normal distribution.",
  "Points that stay close to the dashed line support the normality assumption, while steady bends or extreme outliers hint at skewed or heavy-tailed errors.",
  "If you spot strong patterns in either plot, consider transforming variables, adding predictors, or trying a different model to improve the fit."
)

fit_all_models <- function(df, responses, rhs, strat_details, engine, allow_multi_response) {
  safe_fit <- purrr::safely(reg_fit_model)

  fits <- list()
  success_resps <- character(0)
  error_resps <- character(0)
  success_models <- list()
  error_messages <- list()
  flat_models <- list()
  primary_model <- NULL
  primary_error <- NULL

  for (resp in responses) {
    if (is.null(strat_details$var)) {
      result <- safe_fit(resp, rhs, df, engine = engine)
      entry <- list(
        stratified = FALSE,
        strata = list(list(
          label = NULL,
          display = "Overall",
          model = if (is.null(result$error)) result$result else NULL,
          error = if (!is.null(result$error)) result$error$message else NULL
        ))
      )
      fits[[resp]] <- entry

      if (is.null(result$error)) {
        success_resps <- c(success_resps, resp)
        success_models[[resp]] <- list(Overall = result$result)
        flat_models[[length(flat_models) + 1]] <- list(
          response = resp,
          stratum = NULL,
          model = result$result
        )
        if (is.null(primary_model)) primary_model <- result$result
      } else {
        error_resps <- c(error_resps, resp)
        error_messages[[resp]] <- result$error$message
        if (is.null(primary_error)) primary_error <- result$error$message
      }
    } else {
      strata_entries <- list()
      successful_strata <- list()

      for (level in strat_details$levels) {
        subset_data <- df[df[[strat_details$var]] == level, , drop = FALSE]
        if (nrow(subset_data) == 0) {
          msg <- paste0("No observations available for stratum '", level, "'.")
          strata_entries[[length(strata_entries) + 1]] <- list(
            label = level,
            display = level,
            model = NULL,
            error = msg
          )
          next
        }

        result <- safe_fit(resp, rhs, subset_data, engine = engine)
        if (!is.null(result$error)) {
          strata_entries[[length(strata_entries) + 1]] <- list(
            label = level,
            display = level,
            model = NULL,
            error = result$error$message
          )
        } else {
          strata_entries[[length(strata_entries) + 1]] <- list(
            label = level,
            display = level,
            model = result$result,
            error = NULL
          )
          successful_strata[[level]] <- result$result
          flat_models[[length(flat_models) + 1]] <- list(
            response = resp,
            stratum = level,
            model = result$result
          )
          if (is.null(primary_model)) primary_model <- result$result
        }
      }

      fits[[resp]] <- list(
        stratified = TRUE,
        strata = strata_entries
      )

      if (length(successful_strata) > 0) {
        success_resps <- c(success_resps, resp)
        success_models[[resp]] <- successful_strata
      } else {
        error_resps <- c(error_resps, resp)
        errors_vec <- vapply(
          strata_entries,
          function(entry) {
            if (!is.null(entry$error)) {
              paste0(entry$display, ": ", entry$error)
            } else {
              NA_character_
            }
          },
          character(1)
        )
        errors_vec <- errors_vec[!is.na(errors_vec)]
        combined_error <- paste(errors_vec, collapse = "\n")
        if (!nzchar(combined_error)) combined_error <- "Model fitting failed."
        error_messages[[resp]] <- combined_error
        if (is.null(primary_error)) primary_error <- combined_error
      }
    }
  }

  list(
    responses = responses,
    success_responses = unique(success_resps),
    error_responses = unique(error_resps),
    fits = fits,
    models = success_models,
    flat_models = flat_models,
    model = primary_model,
    errors = error_messages,
    error = primary_error,
    rhs = rhs,
    allow_multi = allow_multi_response,
    stratification = strat_details
  )
}

render_model_summary <- function(engine, model_obj) {
  if (engine == "lm") {
    reg_display_lm_summary(model_obj)
  } else {
    reg_display_lmm_summary(model_obj)
  }
}

render_residual_plot <- function(model_obj) {
  plot_df <- data.frame(
    fitted = stats::fitted(model_obj),
    residuals = stats::residuals(model_obj)
  )

  ggplot2::ggplot(plot_df, ggplot2::aes(x = fitted, y = residuals)) +
    ggplot2::geom_point(color = "steelblue", alpha = 0.8) +
    ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
    ggplot2::labs(
      title = "Residuals vs Fitted",
      x = "Fitted values",
      y = "Residuals"
    ) +
    ggplot2::theme_minimal(base_size = 13)
}

render_qq_plot <- function(model_obj) {
  resid_vals <- stats::residuals(model_obj)
  qq <- stats::qqnorm(resid_vals, plot.it = FALSE)
  qq_df <- data.frame(
    theoretical = qq$x,
    sample = qq$y
  )

  ggplot2::ggplot(qq_df, ggplot2::aes(x = theoretical, y = sample)) +
    ggplot2::geom_point(color = "steelblue", alpha = 0.8) +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    ggplot2::labs(
      title = "Normal Q-Q",
      x = "Theoretical quantiles",
      y = "Sample quantiles"
    ) +
    ggplot2::theme_minimal(base_size = 13)
}

assign_download_handler <- function(output, id, engine, response, stratum_display, model_obj) {
  output[[id]] <- downloadHandler(
    filename = function() {
      parts <- c(engine, "results", response)
      if (!is.null(stratum_display)) parts <- c(parts, stratum_display)
      paste0(paste(parts, collapse = "_"), "_", Sys.Date(), ".docx")
    },
    content = function(file) {
      write_lm_docx(model_obj, file)
    }
  )
}

assign_model_outputs <- function(output, engine, response, idx, model_obj, stratum_idx = NULL, stratum_display = NULL) {
  summary_id <- if (is.null(stratum_idx)) paste0("summary_", idx) else paste0("summary_", idx, "_", stratum_idx)
  resid_id <- if (is.null(stratum_idx)) paste0("resid_", idx) else paste0("resid_", idx, "_", stratum_idx)
  qq_id <- if (is.null(stratum_idx)) paste0("qq_", idx) else paste0("qq_", idx, "_", stratum_idx)
  download_id <- if (is.null(stratum_idx)) paste0("download_", idx) else paste0("download_", idx, "_", stratum_idx)

  output[[summary_id]] <- renderPrint({
    render_model_summary(engine, model_obj)
  })

  output[[resid_id]] <- renderPlot({
    render_residual_plot(model_obj)
  })

  output[[qq_id]] <- renderPlot({
    render_qq_plot(model_obj)
  })

  assign_download_handler(output, download_id, engine, response, stratum_display, model_obj)
}

build_response_content <- function(ns, idx, fit_entry) {
  if (!isTRUE(fit_entry$stratified)) {
    tagList(
      verbatimTextOutput(ns(paste0("summary_", idx))),
      br(),
      h5("Diagnostics"),
      br(),
      fluidRow(
        column(6, plotOutput(ns(paste0("resid_", idx)))),
        column(6, plotOutput(ns(paste0("qq_", idx))))
      ),
      br(),
      helpText(reg_diagnostic_explanation),
      br(),
      br(),
      with_help_tooltip(
        downloadButton(ns(paste0("download_", idx)), "Download results", style = "width: 100%;"),
        "Save the model summary and diagnostics for this response."
      )
    )
  } else {
    strata <- fit_entry$strata
    stratum_tabs <- lapply(seq_along(strata), function(j) {
      stratum <- strata[[j]]
      label <- if (!is.null(stratum$display)) stratum$display else paste("Stratum", j)

      content <- if (!is.null(stratum$model)) {
        tagList(
          verbatimTextOutput(ns(paste0("summary_", idx, "_", j))),
          br(),
          h5("Diagnostics"),
          br(),
          fluidRow(
            column(6, plotOutput(ns(paste0("resid_", idx, "_", j)))),
            column(6, plotOutput(ns(paste0("qq_", idx, "_", j))))
          ),
          br(),
          helpText(reg_diagnostic_explanation),
          br(),
          br(),
          with_help_tooltip(
            downloadButton(ns(paste0("download_", idx, "_", j)), "Download results", style = "width: 100%;"),
            "Save the model summary and diagnostics for this stratum."
          )
        )
      } else {
        tags$pre(format_safe_error_message("Model fitting failed", stratum$error))
      }

      tabPanel(title = label, content)
    })

    do.call(
      tabsetPanel,
      c(list(id = ns(paste0("strata_tabs_", idx))), stratum_tabs)
    )
  }
}

build_model_ui <- function(ns, models_info) {
  success_resps <- models_info$success_responses
  error_resps <- models_info$error_responses
  fits <- models_info$fits

  error_block <- NULL
  if (!is.null(error_resps) && length(error_resps) > 0) {
    error_block <- lapply(error_resps, function(resp) {
      err <- models_info$errors[[resp]]
      tags$pre(
        format_safe_error_message(
          paste("Model fitting failed for", resp),
          if (!is.null(err)) err else ""
        )
      )
    })
  }

  if (is.null(success_resps) || length(success_resps) == 0) {
    if (!is.null(error_block)) return(do.call(tagList, error_block))
    return(NULL)
  }

  panels <- lapply(seq_along(success_resps), function(idx) {
    response <- success_resps[idx]
    fit_entry <- fits[[response]]
    content <- build_response_content(ns, idx, fit_entry)

    if (length(success_resps) > 1) {
      tabPanel(title = response, content)
    } else {
      content
    }
  })

  results_block <- if (length(success_resps) > 1) {
    do.call(tabsetPanel, c(list(id = ns("results_tabs")), panels))
  } else {
    panels[[1]]
  }

  elements <- c(if (!is.null(error_block)) error_block, list(results_block))
  do.call(tagList, elements)
}

render_model_outputs <- function(output, models_info, engine) {
  success_resps <- models_info$success_responses
  fits <- models_info$fits

  if (is.null(success_resps) || length(success_resps) == 0) return()

  for (idx in seq_along(success_resps)) {
    response <- success_resps[idx]
    fit_entry <- fits[[response]]

    if (!isTRUE(fit_entry$stratified)) {
      stratum <- fit_entry$strata[[1]]
      model_obj <- stratum$model
      if (!is.null(model_obj)) {
        assign_model_outputs(output, engine, response, idx, model_obj)
      }
    } else {
      strata <- fit_entry$strata
      for (j in seq_along(strata)) {
        stratum <- strata[[j]]
        if (is.null(stratum$model)) next
        assign_model_outputs(output, engine, response, idx, stratum$model, stratum_idx = j, stratum_display = stratum$display)
      }
    }
  }
}

regression_ui <- function(id, engine = c("lm", "lmm"), allow_multi_response = FALSE) {
  ns <- NS(id)
  engine <- match.arg(engine)
  allow_multi_response <- isTRUE(allow_multi_response)

  list(
    config = tagList(
      if (allow_multi_response) multi_response_ui(ns("response")) else uiOutput(ns("response_ui")),
      uiOutput(ns("fixed_selector")),
      uiOutput(ns("level_order")),
      uiOutput(ns("covar_selector")),
      if (engine == "lmm") uiOutput(ns("random_selector")),
      uiOutput(ns("interaction_select")),
      uiOutput(ns("formula_preview")),
      br(),
      tags$details(
        tags$summary(strong("Advanced options")),
        stratification_ui("strat", ns)
      ),
      br(),
      fluidRow(
        column(6, with_help_tooltip(
          actionButton(ns("run"), "Show results", width = "100%"),
          "Fit the model using the chosen predictors and options."
        )),
        column(6, with_help_tooltip(
          downloadButton(ns("download_model"), "Download all results", style = "width: 100%;"),
          "Export the model outputs, tables, and summaries to your computer."
        ))
      )
    ),
    results = tagList(
      uiOutput(ns("results_ui"))
    )
  )
}

regression_server <- function(id, data, engine = c("lm", "lmm"), allow_multi_response = FALSE) {
  engine <- match.arg(engine)
  allow_multi_response <- isTRUE(allow_multi_response)

  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    strat_info <- stratification_server("strat", data)

    if (allow_multi_response) {
      selected_responses <- multi_response_server("response", data)
    } else {
      output$response_ui <- renderUI({
        req(data())
        types <- reg_detect_types(data())
        with_help_tooltip(
          selectInput(ns("dep"), "Response variable (numeric)", choices = types$num),
          "Choose the outcome that the model should predict."
        )
      })

      selected_responses <- reactive({
        req(input$dep)
        input$dep
      })
    }

    output$fixed_selector <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      with_help_tooltip(
        selectInput(
          ns("fixed"),
          "Categorical predictors",
          choices = types$fac,
          multiple = TRUE
        ),
        "Pick factor variables that might explain differences in the response."
      )
    })

    output$level_order <- renderUI({
      req(data())
      req(input$fixed)

      df <- data()
      fac_vars <- input$fixed

      if (length(fac_vars) == 0) return(NULL)

      tagList(
        lapply(fac_vars, function(var) {
          values <- df[[var]]
          if (is.factor(values)) lvls <- levels(values)
          else {
            values <- values[!is.na(values)]
            lvls <- unique(as.character(values))
          }
          with_help_tooltip(
            selectInput(
              ns(paste0("order_", var)),
              paste("Order of levels (first = reference)", var),
              choices = lvls,
              selected = lvls,
              multiple = TRUE
            ),
            sprintf("Arrange the levels of %s; the first level becomes the model reference.", var)
          )
        })
      )
    })

    output$covar_selector <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      with_help_tooltip(
        selectInput(
          ns("covar"),
          "Numeric predictors",
          choices = types$num,
          multiple = TRUE
        ),
        "Pick numeric predictors that could help explain the response."
      )
    })

    if (engine == "lmm") {
      output$random_selector <- renderUI({
        req(data())
        types <- reg_detect_types(data())
        with_help_tooltip(
          selectInput(
            ns("random"),
            "Random effect (categorical)",
            choices = types$fac,
            selected = NULL
          ),
          "Choose a grouping factor for random intercepts in the mixed model."
        )
      })
    }

    output$interaction_select <- renderUI({
      req(data())
      types <- reg_detect_types(data())
      reg_interactions_ui(ns, input$fixed, types$fac)
    })

    output$formula_preview <- renderUI({
      responses <- selected_responses()
      req(length(responses) > 0)
      rhs <- reg_compose_rhs(
        input$fixed,
        input$covar,
        input$interactions,
        if (engine == "lmm") input$random else NULL,
        engine = engine
      )
      reg_formula_preview_ui(ns, responses[1], rhs)
    })

    models <- eventReactive(input$run, {
      req(data())
      df <- data()
      responses <- selected_responses()
      req(length(responses) > 0)

      rhs <- reg_compose_rhs(
        input$fixed,
        input$covar,
        input$interactions,
        if (engine == "lmm") input$random else NULL,
        engine = engine
      )

      strat_details <- strat_info()
      fit_all_models(df, responses, rhs, strat_details, engine, allow_multi_response)
    })

    output$results_ui <- renderUI({
      mod <- models()
      req(mod)
      build_model_ui(ns, mod)
    })

    observeEvent(models(), {
      mod <- models()
      req(mod)
      render_model_outputs(output, mod, engine)
    }, ignoreNULL = FALSE)

    output$download_model <- downloadHandler(
      filename = function() {
        mod <- models()
        if (is.null(mod) || length(mod$flat_models) == 0) {
          return(paste0(engine, "_results_", Sys.Date(), ".docx"))
        }

        if (length(mod$flat_models) == 1) {
          entry <- mod$flat_models[[1]]
          parts <- c(engine, "results", entry$response)
          if (!is.null(entry$stratum)) parts <- c(parts, entry$stratum)
          paste0(paste(parts, collapse = "_"), "_", Sys.Date(), ".docx")
        } else {
          paste0(engine, "_all_results_", Sys.Date(), ".docx")
        }
      },
      content = function(file) {
        mod <- models()
        if (is.null(mod)) stop("No models available. Please run the analysis first.")
        flat_models <- mod$flat_models
        if (length(flat_models) == 0) stop("No models available. Please run the analysis first.")

        if (length(flat_models) == 1) {
          write_lm_docx(flat_models[[1]]$model, file)
        } else {
          doc <- officer::read_docx()
          for (entry in flat_models) {
            tmp <- tempfile(fileext = ".docx")
            sublab <- if (!is.null(entry$stratum)) paste("Stratum:", entry$stratum) else NULL
            
            # pass subtitle so it appears RIGHT under the title
            write_lm_docx(entry$model, tmp, subtitle = sublab)
            
            doc <- officer::body_add_docx(doc, src = tmp)
            doc <- officer::body_add_par(doc, "", style = "Normal")
          }
          print(doc, target = file)
        }
      }
    )

    df_final <- reactive({
      data()
    })

    model_fit <- reactive({
      mod <- models()
      req(mod)
      mod$models
    })

    compiled_results <- reactive({
      mod <- models()
      req(mod)
      compile_regression_results(mod, engine)
    })

    summary_table <- reactive({
      res <- compiled_results()
      req(res)
      res$summary
    })

    effect_table <- reactive({
      res <- compiled_results()
      req(res)
      res$effects
    })

    error_table <- reactive({
      res <- compiled_results()
      req(res)
      res$errors
    })

    reactive({
      mod <- models()
      req(mod)

      data_used <- df_final()

      list(
        analysis_type = if (engine == "lm") "LM" else "LMM",
        data_used = data_used,
        model = model_fit(),
        summary = summary_table(),
        posthoc = NULL,
        effects = effect_table(),
        stats = if (!is.null(data_used)) list(n = nrow(data_used), vars = names(data_used)) else NULL,
        metadata = list(
          responses = mod$responses,
          success_responses = mod$success_responses,
          error_responses = mod$error_responses,
          errors = mod$errors,
          stratification = mod$stratification,
          rhs = mod$rhs,
          allow_multi = mod$allow_multi,
          compiled_errors = error_table(),
          flat_models = mod$flat_models,
          engine = engine
        ),
        type = if (engine == "lm") "lm" else "lmm",
        fits = mod$fits,
        flat_models = mod$flat_models,
        stratification = mod$stratification,
        responses = mod$responses,
        errors = mod$errors
      )
    })
  })
}
# ===============================================================
# ðŸ”§ Shared helpers for LM/LMM (UI + server utilities)
# ===============================================================

# ---------------------------------------------------------------
# UI setup
# ---------------------------------------------------------------

reg_detect_types <- function(df) {
  num_vars <- names(df)[sapply(df, is.numeric)]
  fac_vars <- names(df)[sapply(df, function(x) is.factor(x) || is.character(x))]
  list(num = num_vars, fac = fac_vars)
}

reg_variable_selectors_ui <- function(ns, types, allow_random = FALSE) {
  out <- list(
    with_help_tooltip(
      selectInput(ns("dep"), "Response variable (numeric)", choices = types$num),
      "Pick the numeric outcome you want the model to explain."
    ),
    with_help_tooltip(
      selectInput(ns("fixed"), "Categorical predictors", choices = types$fac, multiple = TRUE),
      "Select group variables that might influence the response."
    ),
    with_help_tooltip(
      selectInput(ns("covar"), "Numeric predictors", choices = types$num, multiple = TRUE),
      "Select numeric predictors that could explain changes in the response."
    )
  )
  if (allow_random) {
    out <- c(out, list(
      with_help_tooltip(
        selectInput(ns("random"), "Random effect (categorical)", choices = types$fac, selected = NULL),
        "Choose a grouping factor for random intercepts when using mixed models."
      )
    ))
  }
  do.call(tagList, out)
}

reg_interactions_ui <- function(ns, fixed, fac_vars) {
  if (is.null(fixed) || length(fixed) < 2) return(NULL)
  cats_only <- intersect(fixed, fac_vars)
  if (length(cats_only) < 2) return(NULL)
  pairs <- combn(cats_only, 2, simplify = FALSE)
  pair_labels <- vapply(pairs, function(p) paste(p, collapse = " Ã— "), character(1))
  pair_values <- vapply(pairs, function(p) paste(p, collapse = ":"), character(1))
  with_help_tooltip(
    checkboxGroupInput(
      ns("interactions"),
      label = "Select 2-way interactions (optional)",
      choices = stats::setNames(pair_values, pair_labels)
    ),
    "Tick pairs of factors to let the model test if their joint effect matters."
  )
}

# ---------------------------------------------------------------
# Formula construction
# ---------------------------------------------------------------

reg_compose_rhs <- function(fixed, covar, interactions, random = NULL, engine = c("lm","lmm")) {
  engine <- match.arg(engine)
  rhs <- character(0)
  if (!is.null(fixed) && length(fixed) > 0) rhs <- c(rhs, fixed)
  if (!is.null(covar) && length(covar) > 0) rhs <- c(rhs, covar)
  if (!is.null(interactions) && length(interactions) > 0) rhs <- c(rhs, interactions)
  if (engine == "lmm" && !is.null(random) && nzchar(random)) {
    rhs <- c(rhs, paste0("(1|", random, ")"))
  }
  rhs
}

reg_formula_preview_ui <- function(ns, dep, rhs) {
  if (is.null(dep) || !nzchar(dep)) return(NULL)
  form_txt <- if (length(rhs) == 0) paste(dep, "~ 1") else paste(dep, "~", paste(rhs, collapse = " + "))
  wellPanel(
    strong("Model formula: "),
    code(form_txt)
  )
}

# ---------------------------------------------------------------
# Model computation
# ---------------------------------------------------------------

reg_fit_model <- function(dep, rhs, data, engine = c("lm","lmm")) {
  engine <- match.arg(engine)
  form <- as.formula(if (length(rhs) == 0) paste(dep, "~ 1") else paste(dep, "~", paste(rhs, collapse = " + ")))
  if (engine == "lm") {
    lm(form, data = data)
  } else {
    # LMM: lme4 + lmerTest for p-values
    lmerTest::lmer(form, data = data)
  }
}

# ---------------------------------------------------------------
# Output composition
# ---------------------------------------------------------------

reg_display_summary <- function(model, engine = c("lm", "lmm")) {
  engine <- match.arg(engine)

  if (engine == "lm") {
    aout <- capture.output(car::Anova(model, type = 3))
    signif_idx <- grep("^Signif\\. codes", aout)
    if (length(signif_idx) > 0) {
      remove_idx <- c(signif_idx - 1, signif_idx)
      aout <- aout[-remove_idx]
    }
    cat(paste(aout, collapse = "\n"), "\n\n")

    sout <- capture.output(summary(model))
    start <- grep("^Residuals:", sout)[1]
    stop  <- grep("^Signif\\. codes", sout)[1]
    if (!is.na(start)) {
      if (!is.na(stop)) sout <- sout[start:(stop - 2)]
      else sout <- sout[start:length(sout)]
    }
    cat(paste(sout, collapse = "\n"))
  } else {
    aout <- capture.output(anova(model, type = 3))
    cat(paste(aout, collapse = "\n"), "\n\n")

    sout <- capture.output(summary(model))
    start <- grep("^Scaled residuals:", sout)[1]
    stop  <- grep("^Correlation of Fixed Effects:", sout)[1]
    if (!is.na(start)) {
      if (!is.na(stop)) sout <- sout[start:(stop - 1)]
      else sout <- sout[start:length(sout)]
    }

    icc_df <- compute_icc(model)
    if (!is.null(icc_df) && nrow(icc_df) > 0) {
      icc_line <- paste(paste0("ICC (", icc_df$Group, "): ", icc_df$ICC), collapse = "; ")
      random_idx <- grep("^Random effects:", sout)[1]
      if (!is.na(random_idx)) sout <- append(sout, paste0("\n", icc_line), after = random_idx + 4)
      else sout <- c(sout, icc_line)
    }
    cat(paste(sout, collapse = "\n"))
  }
}

reg_display_lm_summary <- function(m) reg_display_summary(m, "lm")

reg_display_lmm_summary <- function(m) reg_display_summary(m, "lmm")

# ---------------------------------------------------------------
# Summaries for standardized regression outputs
# ---------------------------------------------------------------

clean_regression_coef_names <- function(nms) {
  lookup <- c(
    "estimate" = "estimate",
    "std. error" = "std_error",
    "std error" = "std_error",
    "t value" = "statistic",
    "z value" = "statistic",
    "f value" = "statistic",
    "df" = "df",
    "dendf" = "dendf",
    "numdf" = "numdf"
  )

  vapply(nms, function(name) {
    name_trim <- trimws(name)
    key <- tolower(name_trim)
    val <- if (!is.na(key) && key %in% names(lookup)) lookup[[key]] else NULL
    if (!is.null(val)) return(val)
    if (grepl("^Pr\\(>", name_trim)) return("p_value")
    cleaned <- tolower(name_trim)
    cleaned <- gsub("[^[:alnum:]]+", "_", cleaned)
    cleaned <- gsub("^_+|_+$", "", cleaned)
    cleaned <- gsub("_+", "_", cleaned)
    cleaned
  }, character(1), USE.NAMES = FALSE)
}

tidy_regression_model <- function(model, engine) {
  if (is.null(model)) {
    return(list(summary = NULL, effects = NULL))
  }

  coef_mat <- tryCatch(summary(model)$coefficients, error = function(e) NULL)
  coef_df <- NULL
  if (!is.null(coef_mat)) {
    coef_df <- data.frame(
      term = rownames(coef_mat),
      coef_mat,
      row.names = NULL,
      check.names = FALSE,
      stringsAsFactors = FALSE
    )
    original_names <- names(coef_df)
    names(coef_df) <- c("term", clean_regression_coef_names(original_names[-1]))
  }

  metrics <- NULL
  if (inherits(model, "lm")) {
    sm <- summary(model)
    metrics <- data.frame(
      metric = c("sigma", "r_squared", "adj_r_squared", "nobs"),
      value = c(sm$sigma, sm$r.squared, sm$adj.r.squared, stats::nobs(model)),
      stringsAsFactors = FALSE
    )
  } else {
    metrics <- data.frame(
      metric = c("sigma", "logLik", "AIC", "BIC", "nobs"),
      value = c(
        stats::sigma(model),
        as.numeric(stats::logLik(model)),
        stats::AIC(model),
        stats::BIC(model),
        stats::nobs(model)
      ),
      stringsAsFactors = FALSE
    )
  }

  anova_tbl <- tryCatch({
    if (engine == "lm") {
      car::Anova(model, type = 3)
    } else {
      anova(model, type = 3)
    }
  }, error = function(e) NULL)

  if (!is.null(anova_tbl)) {
    anova_tbl <- as.data.frame(anova_tbl)
    anova_tbl$Effect <- rownames(anova_tbl)
    rownames(anova_tbl) <- NULL
    anova_tbl <- anova_tbl[, c("Effect", setdiff(names(anova_tbl), "Effect"))]
  }

  effects <- list(metrics = metrics, anova = anova_tbl)
  if (all(vapply(effects, is.null, logical(1)))) effects <- NULL

  list(summary = coef_df, effects = effects)
}

compile_regression_results <- function(model_info, engine) {
  if (is.null(model_info) || is.null(model_info$fits)) return(NULL)

  summary_list <- list()
  effects_list <- list()
  errors_list <- list()

  for (resp in names(model_info$fits)) {
    fit_entry <- model_info$fits[[resp]]
    if (is.null(fit_entry)) next

    if (isTRUE(fit_entry$stratified)) {
      strata_entries <- fit_entry$strata
      for (stratum in strata_entries) {
        label <- if (!is.null(stratum$display)) stratum$display else stratum$label
        if (is.null(label) || !nzchar(label)) label <- "Stratum"
        tidy <- tidy_regression_model(stratum$model, engine)
        if (is.null(summary_list[[resp]])) summary_list[[resp]] <- list()
        if (is.null(effects_list[[resp]])) effects_list[[resp]] <- list()
        summary_list[[resp]][[label]] <- tidy$summary
        effects_list[[resp]][[label]] <- tidy$effects
        if (!is.null(stratum$error)) {
          if (is.null(errors_list[[resp]])) errors_list[[resp]] <- list()
          errors_list[[resp]][[label]] <- stratum$error
        }
      }
    } else {
      stratum <- fit_entry$strata[[1]]
      tidy <- tidy_regression_model(stratum$model, engine)
      summary_list[[resp]] <- tidy$summary
      effects_list[[resp]] <- tidy$effects
      if (!is.null(stratum$error)) {
        errors_list[[resp]] <- stratum$error
      }
    }
  }

  list(summary = summary_list, effects = effects_list, errors = errors_list)
}

# ===============================================================
# Results export
# ===============================================================

write_lm_docx <- function(model, file, subtitle = NULL) {
  
  # Determine model type
  is_lmm <- inherits(model, "merMod")
  dep_var <- all.vars(formula(model))[1]

  # Helper for consistent table formatting
  format_table <- function(df, bold_p = TRUE) {
    ft <- flextable(df)
    ft <- fontsize(ft, part = "all", size = 10)
    ft <- bold(ft, part = "header", bold = TRUE)
    ft <- color(ft, part = "header", color = "black")
    ft <- align(ft, align = "center", part = "all")
    ft <- border_remove(ft)
    black <- fp_border(color = "black", width = 1)
    ft <- border(ft, part = "header", border.top = black)
    ft <- border(ft, part = "header", border.bottom = black)
    if (nrow(df) > 0) {
      ft <- border(ft, i = nrow(df), part = "body", border.bottom = black)
    }

    # Bold significant p-values
    if (bold_p) {
      p_cols <- names(df)[grepl("Pr", names(df), fixed = TRUE)]
      for (pcol in p_cols) {
        if (is.numeric(df[[pcol]]) || all(grepl("^[0-9.<]+$", df[[pcol]]))) {
          sig_rows <- suppressWarnings(which(as.numeric(df[[pcol]]) < 0.05))
          if (length(sig_rows) == 0) {
            # handle formatted p-values like "<0.001"
            sig_rows <- grep("<0\\.0*1", df[[pcol]])
          }
          if (length(sig_rows) > 0 && pcol %in% ft$col_keys) {
            ft <- bold(ft, i = sig_rows, j = pcol, bold = TRUE)
          }
        }
      }
    }

    ft <- set_table_properties(ft, layout = "autofit", width = 0.9)
    ft <- padding(ft, padding.top = 2, padding.bottom = 2, padding.left = 2, padding.right = 2)
    ft
  }

  # Create new Word document
  doc <- read_docx()
  
  # ---- Title ----
  title_text <- sprintf(
    "%s Results â€” %s",
    if (is_lmm) "Linear Mixed Model" else "Linear Model",
    dep_var
  )
  doc <- body_add_fpar(
    doc,
    fpar(ftext(title_text, prop = fp_text(bold = TRUE, font.size = 12)))
  )
  
  # ---- Subtitle (Stratum, if any) ----
  if (!is.null(subtitle) && nzchar(subtitle)) {
    subtitle_text <- ftext(
      subtitle,
      prop = fp_text(bold = TRUE, font.size = 11)
    )
    doc <- body_add_fpar(doc, fpar(subtitle_text))
  }
  
  doc <- body_add_par(doc, "")
  
  # ==========================================================
  # ðŸ”¹ ANOVA (Type III)
  # ==========================================================
  doc <- body_add_fpar(doc, fpar(ftext("ANOVA (Type III)", prop = fp_text(bold = TRUE))))
  doc <- body_add_par(doc, "")

  if (is_lmm) {
    anova_tbl <- as.data.frame(anova(model, type = 3))
  } else {
    anova_tbl <- as.data.frame(car::Anova(model, type = 3))
  }
  anova_tbl <- tibble::rownames_to_column(anova_tbl, "Effect")

  # Round numeric columns and format p-values
  for (col in names(anova_tbl)) {
    if (is.numeric(anova_tbl[[col]])) anova_tbl[[col]] <- round(anova_tbl[[col]], 3)
  }
  p_col <- grep("^Pr", names(anova_tbl), value = TRUE)
  if (length(p_col) > 0) {
    colnames(anova_tbl)[colnames(anova_tbl) == p_col[1]] <- "Pr(>F)"
  }

  ft_anova <- format_table(anova_tbl)
  doc <- body_add_flextable(doc, ft_anova)
  doc <- body_add_par(doc, "")

  # ==========================================================
  # ðŸ”¹ Random Effects & ICC (LMM only)
  # ==========================================================
  if (is_lmm) {
    # ---- Random Effects ----
    doc <- body_add_fpar(doc, fpar(ftext("Random Effects", prop = fp_text(bold = TRUE))))
    doc <- body_add_par(doc, "")

    rand_df <- as.data.frame(lme4::VarCorr(model))
    if (nrow(rand_df) > 0) {
      rand_df <- rand_df[, c("grp", "var1", "var2", "vcov", "sdcor"), drop = FALSE]
      rand_df$var2 <- ifelse(is.na(rand_df$var2), "-", rand_df$var2)
      names(rand_df) <- c("Grouping", "Effect 1", "Effect 2", "Variance", "Std. Dev.")
      rand_df$Variance <- round(rand_df$Variance, 3)
      rand_df$`Std. Dev.` <- round(rand_df$`Std. Dev.`, 3)
      ft_rand <- format_table(rand_df, bold_p = FALSE)
      doc <- body_add_flextable(doc, ft_rand)
    } else {
      doc <- body_add_par(doc, "No random-effect variance components were estimated.", style = "Normal")
    }

    # ---- ICC ----
    if (exists("compute_icc") && is.function(compute_icc)) {
      icc_df <- compute_icc(model)
    } else {
      icc_df <- NULL
    }
    if (!is.null(icc_df) && nrow(icc_df) > 0) {
      doc <- body_add_par(doc, "")
      doc <- body_add_fpar(doc, fpar(ftext("Intraclass Correlation (ICC)", prop = fp_text(bold = TRUE))))
      doc <- body_add_par(doc, "")
      icc_df$ICC <- round(icc_df$ICC, 3)
      ft_icc <- format_table(icc_df, bold_p = FALSE)
      doc <- body_add_flextable(doc, ft_icc)
    }

    doc <- body_add_par(doc, "")
  }

  # ==========================================================
  # ðŸ”¹ Model Coefficients
  # ==========================================================
  doc <- body_add_fpar(doc, fpar(ftext("Model Coefficients", prop = fp_text(bold = TRUE))))
  doc <- body_add_par(doc, "")

  coef_tbl <- as.data.frame(summary(model)$coefficients)
  coef_tbl <- tibble::rownames_to_column(coef_tbl, "Term")
  names(coef_tbl)[1] <- "Term"
  names(coef_tbl) <- gsub("Pr\\(>\\|t\\|\\)", "Pr(>|t|)", names(coef_tbl))

  for (col in names(coef_tbl)) {
    if (is.numeric(coef_tbl[[col]])) coef_tbl[[col]] <- round(coef_tbl[[col]], 4)
  }

  ft_coef <- format_table(coef_tbl)
  doc <- body_add_flextable(doc, ft_coef)

  # ==========================================================
  # ðŸ”¹ Footer
  # ==========================================================
  doc <- body_add_par(doc, "")
  doc <- body_add_par(doc, "Significance level: p < 0.05 (bold values).", style = "Normal")
  doc <- body_add_par(doc, sprintf("Generated by Table Analyzer on %s", Sys.Date()))

  # Save file
  print(doc, target = file)
}

# ===============================================================
# ðŸ”¤ Base size controls shared submodule
# ===============================================================

base_size_ui <- function(ns,
                         input_id = "plot_base_size",
                         default = 13,
                         min = 6,
                         max = 30,
                         step = 1,
                         help_text = "Adjust the base font size used for plot text.") {
  tagList(
    shiny::singleton(
      tags$style(
        HTML(
          "\n        .ta-base-size-input .shiny-input-container,\n        .ta-base-size-input .form-group {\n          margin-bottom: 0;\n        }\n        .ta-base-size-input input.form-control {\n          height: 32px;\n          padding: 4px 10px;\n        }\n      "
        )
      )
    ),
    h5("Base size"),
    div(
      class = "ta-base-size-input",
      with_help_tooltip(
        numericInput(
          inputId = ns(input_id),
          label = NULL,
          value = default,
          min = min,
          max = max,
          step = step,
          width = "100%"
        ),
        help_text
      )
    )
  )
}

base_size_server <- function(input,
                             input_id = "plot_base_size",
                             default = 13) {
  reactive({
    value <- input[[input_id]]
    if (is.null(value) || !is.numeric(value) || length(value) == 0 || is.na(value)) {
      default
    } else {
      value
    }
  })
}
# ===============================================================
# ðŸ” Multi-Response Selector Module (final simple version)
# ===============================================================

multi_response_ui <- function(id) {
  ns <- NS(id)
  tagList(
    with_help_tooltip(
      checkboxInput(
        ns("multi_resp"),
        "Allow multiple response variables",
        value = FALSE
      ),
      "Tick this to analyse several response variables one after another."
    ),
    uiOutput(ns("response_ui"))
  )
}

multi_response_server <- function(id, data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    df <- reactive({
      d <- if (is.function(data)) data() else data
      req(is.data.frame(d))
      d
    })
    
    # --- Re-render only when multi-select mode changes
    output$response_ui <- renderUI({
      d <- req(df())
      num_vars <- names(d)[sapply(d, is.numeric)]
      validate(need(length(num_vars) > 0, "No numeric variables available."))
      
      with_help_tooltip(
        selectInput(
          ns("response"),
          label = if (isTRUE(input$multi_resp))
            "Response variables (numeric)"
          else
            "Response variable (numeric)",
          choices = num_vars,
          selected = num_vars[1],
          multiple = isTRUE(input$multi_resp)
        ),
        "Choose the numeric outcomes the model should process."
      )
    })
    
    # --- Reactive standardized vector
    reactive({
      res <- req(input$response)
      if (!isTRUE(input$multi_resp)) res <- res[1]
      unique(res)
    })
  })
}
# ===============================================================
# ðŸ§­ Stratification helpers (shared across analysis modules)
# ===============================================================

MAX_STRATIFICATION_LEVELS <- 10

stratification_ui <- function(id, ns = NULL) {
  ns_fn <- if (is.null(ns)) {
    NS(id)
  } else if (is.function(ns)) {
    function(x) ns(paste(id, x, sep = "-"))
  } else {
    NS(id)
  }
  
  tagList(
    uiOutput(ns_fn("stratify_var_ui")),
    uiOutput(ns_fn("strata_order_ui"))
  )
}

stratification_server <- function(id, data) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    
    df <- reactive({
      d <- if (is.function(data)) data() else data
      req(is.data.frame(d))
      validate(need(nrow(d) > 0, "No data available for stratification."))
      d
    })
    
    # ---- UI: variable selector ----
    output$stratify_var_ui <- renderUI({
      d <- req(df())
      cat_cols <- names(d)[vapply(d, function(x) is.factor(x) || is.character(x), logical(1))]
      with_help_tooltip(
        selectInput(
          ns("stratify_var"),
          "Stratify by",
          choices = c("None", cat_cols),
          selected = "None"
        ),
        "Pick a categorical variable if you want separate summaries for each group."
      )
    })
    
    # ---- UI: order/levels selector ----
    output$strata_order_ui <- renderUI({
      req(input$stratify_var)
      if (input$stratify_var == "None") return(NULL)
      d <- req(df())
      
      values <- d[[input$stratify_var]]
      values <- values[!is.na(values)]
      available_levels <- if (is.factor(values)) levels(values) else unique(as.character(values))
      available_levels <- available_levels[nzchar(available_levels)]
      
      n_levels <- length(available_levels)
      validate(need(n_levels <= MAX_STRATIFICATION_LEVELS,
                    sprintf("'%s' has too many levels (%d > %d).",
                            input$stratify_var, n_levels, MAX_STRATIFICATION_LEVELS)))
      
      with_help_tooltip(
        selectInput(
          ns("strata_order"),
          "Order of levels",
          choices = available_levels,
          selected = available_levels,
          multiple = TRUE
        ),
        "Decide which group levels to include and in what order they should appear."
      )
    })
    
    # ---- Unified reactive output ----
    reactive({
      list(
        var = if (identical(input$stratify_var, "None")) NULL else input$stratify_var,
        levels = input$strata_order
      )
    })
  })
}
  

